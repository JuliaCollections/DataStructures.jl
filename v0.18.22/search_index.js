var documenterSearchIndex = {"docs":
[{"location":"circ_deque/#CircularDeque","page":"CircularDeque","title":"CircularDeque","text":"","category":"section"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"The CircularDeque type implements a double-ended queue using a circular buffer of fixed capacity. This data structure supports constant-time insertion/removal of elements at both ends of a sequence.","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Usage:","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"a = CircularDeque{Int}(n)   # allocate a deque with maximum capacity n\nisempty(a)          # test whether the deque is empty\nempty!(a)           # reset the deque\ncapacity(a)         # return capacity\nlength(a)           # get the number of elements currently in the deque\npush!(a, 10)        # add an element to the back\npop!(a)             # remove an element from the back\npushfirst!(a, 20)   # add an element to the front\npopfirst!(a)        # remove an element from the front\nfirst(a)            # get the element at the front\nlast(a)             # get the element at the back\neltype(a)           # return type of items","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Note: Julia's Vector type also provides this interface, and thus can be used as a deque. However, the CircularDeque type in this package is implemented as a circular buffer, and thus avoids copying elements when modifications are made to the front of the vector.","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Benchmarks show that the performance of CircularDeque is several times faster than Deque.","category":"page"},{"location":"stack_and_queue/#Stack-and-Queue","page":"Stack and Queue","title":"Stack and Queue","text":"","category":"section"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"The Stack and Queue types are a light-weight wrapper of a deque type, which respectively provide interfaces for LIFO and FIFO access.","category":"page"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"Usage of Stack:","category":"page"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"s = Stack{Int}()                # create a stack\nisempty(s)                      # check whether the stack is empty\nlength(s)                       # get the number of elements\neltype(s)                       # get the type of elements\npush!(s, 1)                     # push back a item\nfirst(s)                        # get an item from the top of stack\npop!(s)                         # get and remove a first item\nempty!(s)                       # make a stack empty\niterate(s::Stack)               # Get a LIFO iterator of a stack\nIterators.reverse(s::Stack{T})  # Get a FILO iterator of a stack\ns1 == s2                        # check whether the two stacks are same","category":"page"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"Usage of Queue:","category":"page"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"q = Queue{Int}()\nenqueue!(q, x)\nx = first(q)\nx = last(q)\nx = dequeue!(q)","category":"page"},{"location":"stack_and_queue/","page":"Stack and Queue","title":"Stack and Queue","text":"Both Stack and Queue implement the Iterator interface; iterating over Stack returns items in FILO order and iterating over Queue returns items in FIFO order. There is also a reverse_iter function implemented for both which returns items in the reverse order for each type (i.e. FIFO for Stack and LIFO for Queue).","category":"page"},{"location":"disjoint_sets/#Disjoint-Sets","page":"Disjoint Sets","title":"Disjoint Sets","text":"","category":"section"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"Some algorithms, such as finding connected components in undirected graph and Kruskal's method of finding minimum spanning tree, require a data structure that can efficiently represent a collection of disjoint subsets. A widely used data structure for this purpose is the Disjoint set forest.","category":"page"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"Usage:","category":"page"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"a = IntDisjointSets(10)  # creates a forest comprised of 10 singletons\nunion!(a, 3, 5)          # merges the sets that contain 3 and 5 into one and returns the root of the new set\nroot_union!(a, x, y)     # merges the sets that have root x and y into one and returns the root of the new set\nfind_root(a, 3)          # finds the root element of the subset that contains 3\nin_same_set(a, x, y)     # determines whether x and y are in the same set\nelem = push!(a)          # adds a single element in a new set; returns the new element\n                         # (this operation is often called MakeSet)","category":"page"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"One may also use other element types:","category":"page"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"a = DisjointSets{AbstractString}([\"a\", \"b\", \"c\", \"d\"])\nunion!(a, \"a\", \"b\")\nin_same_set(a, \"c\", \"d\")\npush!(a, \"f\")","category":"page"},{"location":"disjoint_sets/","page":"Disjoint Sets","title":"Disjoint Sets","text":"Note that the internal implementation of IntDisjointSets is based on vectors, and is very efficient. DisjointSets{T} is a wrapper of IntDisjointSets, which uses a dictionary to map input elements to an internal index. Note for DisjointSets, union!, root_union! and find_root return the index of the root.","category":"page"},{"location":"deque/#Deque","page":"Deque","title":"Deque","text":"","category":"section"},{"location":"deque/","page":"Deque","title":"Deque","text":"The Deque type implements a double-ended queue using a list of blocks. This data structure supports constant-time insertion/removal of elements at both ends of a sequence.","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"Usage:","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"a = Deque{Int}()\nisempty(a)          # test whether the dequeue is empty\nlength(a)           # get the number of elements\npush!(a, 10)        # add an element to the back\npop!(a)             # remove an element from the back\npushfirst!(a, 20)   # add an element to the front\npopfirst!(a)        # remove an element from the front\nfirst(a)            # get the element at the front\nlast(a)             # get the element at the back","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"Note: Julia's Vector type also provides this interface, and thus can be used as a deque. However, the Deque type in this package is implemented as a list of contiguous blocks (default size = 2K). As a deque grows, new blocks may be created and linked to existing blocks. This way avoids the copying when growing a vector.","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"Benchmark shows that the performance of Deque is comparable to Vector on push!, and is noticeably faster on pushfirst! (by about 30% to 40%).","category":"page"},{"location":"sparse_int_set/#DataStructures.SparseIntSet","page":"DataStructures.SparseIntSet","title":"DataStructures.SparseIntSet","text":"","category":"section"},{"location":"sparse_int_set/","page":"DataStructures.SparseIntSet","title":"DataStructures.SparseIntSet","text":"Implementation of a Sparse Integer Set, for background see Sparse Sets. Only positive non-zero Ints are allowed inside the set. The idea is to have one packed Vector storing all the Ints contained in the set as to allow for fast iteration, and a sparse, paged reverse Vector with the position of a particular Int inside the packed Vector. This allows for very fast iteration, insertion and deletion of indices. Most behavior is similar to a normal IntSet, however collect, first and last are with respected to the packed vector, in which the ordering is not guaranteed. The reverse Vector is paged, meaning that it is a Vector{Vector{Int}} where each of the Vector{Int}s has the length of one memory page of Ints. Every time an index that was not yet in the range of the already present pages, a new one will be created and added to the reverse, allowing for dynamical growth. Popping the last Int of a particular page will automatically clean up the memory of that page.","category":"page"},{"location":"default_dict/#DefaultDict-and-DefaultOrderedDict","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"","category":"section"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"A DefaultDict allows specification of a default value to return when a requested key is not in a dictionary.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"While the implementation is slightly different, a DefaultDict can be thought to provide a normal Dict with a default value. A DefaultOrderedDict does the same for an OrderedDict.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Constructors:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"DefaultDict(default, kv)    # create a DefaultDict with a default value or function,\n                            # optionally wrapping an existing dictionary\n                            # or array of key-value pairs\n\nDefaultDict{KeyType, ValueType}(default)   # create a DefaultDict with Dict type (KeyType,ValueType)\n\nDefaultOrderedDict(default, kv)     # create a DefaultOrderedDict with a default value or function,\n                                    # optionally wrapping an existing dictionary\n                                    # or array of key-value pairs\n\nDefaultOrderedDict{KeyType, ValueType}(default) # create a DefaultOrderedDict with Dict type (KeyType,ValueType)","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"All constructors also take a passkey::Bool=false keyword argument which determines whether to pass along the key argument when calling the default function. It has no effect when the key is just a value.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Examples using DefaultDict:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"using DataStructures","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict(1)               # create an (Any=>Any) DefaultDict with a default value of 1","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Int}(0)  # create a (AbstractString=>Int) DefaultDict with a default value of 0","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"d = Dict('a'=>1, 'b'=>2)\ndd = DefaultDict(0, d)            # provide a default value to an existing dictionary\nd['c']  # should raise a KeyError because 'c' key doesn't exist\ndd['c']","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultOrderedDict(time)     # call time() to provide the default value for an OrderedDict\ndd = DefaultDict(Dict)            # Create a dictionary of dictionaries - Dict() is called to provide the default value\ndd = DefaultDict(()->myfunc())    # call function myfunc to provide the default value","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"These all create the same default dict","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(() -> Vector{Int}())","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(() -> Int[])","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(Vector{Int})\n\npush!(dd[\"A\"], 1)\n\npush!(dd[\"B\"], 2)\n\ndd","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Create a Dictionary of type AbstractString=>DefaultDict{AbstractString, Int}, where the default of the inner set of DefaultDicts is zero","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, DefaultDict}(() -> DefaultDict{AbstractString,Int}(0))","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Use DefaultDict to cache an expensive function call, i.e., memoize","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Int}(passkey=true) do key\n    len = length(key)\n    sleep(len)\n    return len\nend\n\ndd[\"hi\"]  # slow\n\ndd[\"ho\"]  # slow\n\ndd[\"hi\"]  # fast","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Note that in the second-last example, we need to use a function to create each new DefaultDict. If we forget, we will end up using the sameDefaultDict for all default values:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, DefaultDict}(DefaultDict{AbstractString,Int}(0));\ndd[\"a\"]\ndd[\"b\"][\"a\"] = 1\ndd[\"a\"]","category":"page"},{"location":"sorted_containers/#Sorted-Containers","page":"Sorted Containers","title":"Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"CurrentModule = DataStructures","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Three sorted containers are provided: SortedDict, SortedMultiDict and SortedSet. SortedDict is similar to the built-in Julia type Dict with the additional feature that the keys are stored in sorted order and can be efficiently iterated in this order. SortedDict is a subtype of AbstractDict. It is generally slower than Dict because looking up a key requires an O(log n) tree search rather than an expected O(1) hash-table lookup time as with Dict. SortedDict is a parametrized type with three parameters, the key type K, the value type V, and the ordering type O. SortedSet has only keys; it is an alternative to the built-in Set container. Internally, SortedSet is implemented as a SortedDict in which the value type is Void. Finally, SortedMultiDict is similar to SortedDict except that each key can be associated with multiple values. The key=>value pairs in a SortedMultiDict are stored according to the sorted order for keys, and key=>value pairs with the same key are stored in order of insertion.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The containers internally use a 2-3 tree, which is a kind of balanced tree and is described in many elementary data structure textbooks.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The containers require two functions to compare keys: a less-than and equals function. With the default ordering argument, the comparison functions are isless(key1,key2) (true when key1 < key2) and isequal(key1,key2) (true when key1 == key2) where key1 and key2 are keys. More details are provided below.","category":"page"},{"location":"sorted_containers/#Tokens-for-Sorted-Containers","page":"Sorted Containers","title":"Tokens for Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The sorted container objects use a special type for indexing called a token defined as a two-entry tuple and aliased as SDToken, SMDToken, and SetToken for SortedDict, SortedMultiDict and SortedSet respectively. A token is the address of a single data item in the container and can be dereferenced in time O(1).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The first entry of a Token tuple is the container as a whole, and the second refers to the particular item. The second part is called a semitoken. The types for a semitoken are SDSemiToken, SMDSemiToken, and SetSemiToken for the three types of containers SortedDict, SortedMultiDict and SortedSet. These types are all aliases of IntSemiToken.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"A restriction for the sorted containers is that IntSemiToken or its aliases cannot used as the key-type. This is because ambiguity would result between the two subscripting calls sc[k] and sc[st] described below. In the rare scenario that a sorted container whose key-type is IntSemiToken is required, a workaround is to wrap the key inside another immutable structure.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In the current version of Julia, it is costly to operate on tuples whose entries are not bits-types because such tuples are allocated on the heap. For example, the first entry of a token is a pointer to a container (a non-bits type), so a new token is allocated on the heap rather than the stack. In order to avoid performance loss, the package uses tokens less frequently than semitokens. For a function taking a token as an argument like deref described below, if it is invoked by explicitly naming the token like this:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"tok = (sc,st)   # sc is a sorted container, st is a semitoken\nk,v = deref(tok)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"then there may be a loss of performance compared to:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"k,v = deref((sc,st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"because the former may need an extra heap allocation step for tok.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The notion of token is similar to the concept of iterators used by C++ standard containers. Tokens can be explicitly advanced or regressed through the data in the sorted order; they are implicitly advanced or regressed via iteration loops defined below.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"A token may take two special values: the before-start value and the past-end value. These values act as lower and upper bounds on the actual data. The before-start token can be advanced, while the past-end token can be regressed. A dereferencing operation on either leads to an error.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In the current implementation, semitokens are internally stored as integers. However, for the purpose of future compatibility, the user should not extract this internal representation; these integers do not have a documented interpretation in terms of the container.","category":"page"},{"location":"sorted_containers/#Constructors-for-Sorted-Containers","page":"Sorted Containers","title":"Constructors for Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/#SortedDict-constructors","page":"Sorted Containers","title":"SortedDict constructors","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedDict(o::Ord) where {Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedDict-Tuple{Ord} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(o=Forward)\n\nConstruct an empty SortedDict with key type K and value type V. If K and V are not specified, the dictionary defaults to a SortedDict{Any,Any}. Keys and values are converted to the given type upon insertion. Ordering o defaults to Forward ordering.\n\nNote that a key type of Any or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors below in which the key type is inferred.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedDict{K,V}(o=Forward)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Construct an empty SortedDict with key type K and value type V with o ordering (default to forward ordering).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedDict{K,D,Ord}(o::Ord) where {K, D, Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{Ord}, Tuple{D}, Tuple{K}} where {K, D, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(iter, o=Forward)\n\nand SortedDict{K,V}(iter, o=Forward)\n\nConstruct a SortedDict from an arbitrary iterable object of key=>value pairs. If K and V are not specified, the key type and value type are inferred from the given iterable. The ordering object o defaults to Forward.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedDict(ps::Pair...)","category":"page"},{"location":"sorted_containers/#DataStructures.SortedDict-Tuple{Vararg{Pair}}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(k1=>v1, k2=>v2, ...)\n\nand SortedDict{K,V}(k1=>v1, k2=>v2, ...)\n\nConstruct a SortedDict from the given key-value pairs. If K and V are not specified, key type and value type are inferred from the given key-value pairs, and ordering is assumed to be Forward ordering.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedDict{K,D}(o::Ord, ps::Pair...) where {K,D,Ord<:Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{Ord}, Tuple{D}, Tuple{K}, Tuple{Ord, Vararg{Pair}}} where {K, D, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict{K,V}(o, k1=>v1, k2=>v2, ...)\n\nConstruct a SortedDict from the given pairs with the specified ordering o. If K and V are not specified, the key type and value type are inferred from the given pairs. See below for more information about ordering.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#SortedMultiDict-constructors","page":"Sorted Containers","title":"SortedMultiDict constructors","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict(ks, vs, o)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Construct a SortedMultiDict using keys given by ks, values given by vs and ordering object o. The ordering object defaults to Forward if not specified. The two arguments ks and vs are 1-dimensional arrays of the same length in which ks holds keys and vs holds the corresponding values.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict{K,D,Ord}(o::Ord) where {K,D,Ord}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{Ord}, Tuple{D}, Tuple{K}} where {K, D, Ord}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict{K,D}(iter)\n\nTakes an arbitrary iterable object of key=>value pairs with key type K and value type D. The default Forward ordering is used.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict()","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Tuple{}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict()\n\nConstruct an empty SortedMultiDict with key type Any and value type Any. Ordering defaults to Forward ordering.\n\nNote that a key type of Any or any other abstract type will lead to slow performance.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict(o::O) where {O<:Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Tuple{O} where O<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(o)\n\nConstruct an empty SortedMultiDict with key type Any and value type Any, ordered using o.\n\nNote that a key type of Any or any other abstract type will lead to slow performance.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict(ps::Pair...)","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Tuple{Vararg{Pair}}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(k1=>v1, k2=>v2, ...)\n\nArguments are key-value pairs for insertion into the multidict. The keys must be of the same type as one another; the values must also be of one type.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict(o::Ordering, ps::Pair...)","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Tuple{Base.Order.Ordering, Vararg{Pair}}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(o, k1=>v1, k2=>v2, ...)\n\nThe first argument o is an ordering object. The remaining arguments are key-value pairs for insertion into the multidict. The keys must be of the same type as one another; the values must also be of one type.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict{K,D}(kv) where {K,D}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{D}, Tuple{K}} where {K, D}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict{K,D}(iter)\n\nTakes an arbitrary iterable object of key=>value pairs with key type K and value type D. The default Forward ordering is used.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedMultiDict{K,D}(o::Ord, kv) where {K,D,Ord<:Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{Ord}, Tuple{D}, Tuple{K}, Tuple{Ord, Any}} where {K, D, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict{K,D}(o, iter)\n\nTakes an arbitrary iterable object of key=>value pairs with key type K and value type D. The ordering object o is explicitly given.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#SortedSets-constructors","page":"Sorted Containers","title":"SortedSets constructors","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedSet{K, Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedSet","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet(iter, o=Forward)\n\nand     SortedSet{K}(iter, o=Forward) and     SortedSet(o, iter) and     SortedSet{K}(o, iter)\n\nConstruct a SortedSet using keys given by iterable iter (e.g., an array) and ordering object o. The ordering object defaults to Forward if not specified.\n\n\n\n\n\n","category":"type"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedSet()","category":"page"},{"location":"sorted_containers/#DataStructures.SortedSet-Tuple{}","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet()\n\nConstruct a SortedSet{Any} with Forward ordering.\n\nNote that a key type of Any or any other abstract type will lead to slow performance.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedSet(o::O) where {O<:Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedSet-Tuple{O} where O<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet(o)\n\nConstruct a SortedSet{Any} with o ordering.\n\nNote that a key type of Any or any other abstract type will lead to slow performance.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedSet{K}() where {K}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedSet-Union{Tuple{}, Tuple{K}} where K","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet{K}()\n\nConstruct a SortedSet of keys of type K with Forward ordering.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"SortedSet{K}(o::O) where {K,O<:Ordering}","category":"page"},{"location":"sorted_containers/#DataStructures.SortedSet-Union{Tuple{O}, Tuple{K}} where {K, O<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet{K}(o)\n\nConstruct a SortedSet of keys of type K with ordering given according o parameter.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Complexity-of-Sorted-Containers","page":"Sorted Containers","title":"Complexity of Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In the list of functions below, the running time of the various operations is provided. In these running times, n denotes the current size (number of items) in the container at the time of the function call, and c denotes the time needed to compare two keys.","category":"page"},{"location":"sorted_containers/#Navigating-the-Containers","page":"Sorted Containers","title":"Navigating the Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"getindex(m::SortedDict, k_)","category":"page"},{"location":"sorted_containers/#Base.getindex-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.getindex","text":"v = sd[k]\n\nArgument sd is a SortedDict and k is a key. In an expression, this retrieves the value (v) associated with the key (or KeyError if none). On the left-hand side of an assignment, this assigns or reassigns the value associated with the key. (For assigning and reassigning, see also insert! below.) Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"deref((sc, st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token (i.e., sc is a container and st is a semitoken). Note the double-parentheses in the calling syntax: the argument of deref is a token, which is defined to be a 2-tuple. This returns a key=>value pair. pointed to by the token for SortedDict and SortedMultiDict. Note that the syntax k,v=deref((sc,st)) is valid because Julia automatically iterates over the two entries of the Pair in order to assign k and v. For SortedSet this returns a key. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"deref_key((sc, st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token for SortedMultiDict or SortedDict. This returns the key (i.e., the first half of a key=>value pair) pointed to by the token. This functionality is available as plain deref for SortedSet. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"deref_value((sc, st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token for SortedMultiDict or SortedDict. This returns the value (i.e., the second half of a key=>value pair) pointed to by the token. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"startof(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is SortedDict, SortedMultiDict or SortedSet. This function returns the semitoken of the first item according to the sorted order in the container. If the container is empty, it returns the past-end semitoken. Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"endof(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the semitoken of the last item according to the sorted order in the container. If the container is empty, it returns the before-start semitoken. Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"first(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.first-Tuple{SortedDict}","page":"Sorted Containers","title":"Base.first","text":"first(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"first(sc::SortedMultiDict)","category":"page"},{"location":"sorted_containers/#Base.first-Tuple{SortedMultiDict}","page":"Sorted Containers","title":"Base.first","text":"first(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"first(sc::SortedSet)","category":"page"},{"location":"sorted_containers/#Base.first-Tuple{SortedSet}","page":"Sorted Containers","title":"Base.first","text":"first(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"last(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.last-Tuple{SortedDict}","page":"Sorted Containers","title":"Base.last","text":"last(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"last(sc::SortedMultiDict)","category":"page"},{"location":"sorted_containers/#Base.last-Tuple{SortedMultiDict}","page":"Sorted Containers","title":"Base.last","text":"last(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"last(sc::SortedSet)","category":"page"},{"location":"sorted_containers/#Base.last-Tuple{SortedSet}","page":"Sorted Containers","title":"Base.last","text":"last(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"pastendsemitoken(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the past-end semitoken. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"beforestartsemitoken(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the before-start semitoken. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"advance((sc,st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token. This function returns the semitoken of the next entry in the container according to the sort order of the keys. After the last item, this routine returns the past-end semitoken. It is an error to invoke this function if (sc,st) is the past-end token. If (sc,st) is the before-start token, then this routine returns the semitoken of the first item in the sort order (i.e., the same semitoken returned by the startof function). Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"regress((sc,st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token. This function returns the semitoken of the previous entry in the container according to the sort order of the keys. If (sc,st) indexes the first item, this routine returns the before-start semitoken. It is an error to invoke this function if (sc,st) is the before-start token. If (sc,st) is the past-end token, then this routine returns the smitoken of the last item in the sort order (i.e., the same semitoken returned by the endof function). Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"searchsortedfirst(sc,k)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet and k is a key. This routine returns the semitoken of the first item in the container whose key is greater than or equal to k. If there is no such key, then the past-end semitoken is returned. Time: O(c log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"searchsortedlast(sc,k)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet and k is a key. This routine returns the semitoken of the last item in the container whose key is less than or equal to k. If there is no such key, then the before-start semitoken is returned. Time: O(c log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"searchsortedafter(sc,k)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet and k is an element of the key type. This routine returns the semitoken of the first item in the container whose key is greater than k. If there is no such key, then the past-end semitoken is returned. Time: O(c log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"searchequalrange(sc,k)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedMultiDict and k is an element of the key type. This routine returns a pair of semitokens; the first of the pair is the semitoken addressing the first item in the container with key k and the second is the semitoken addressing the last item in the container with key k. If no item matches the given key, then the pair (past-end-semitoken, before-start-semitoken) is returned. Time: O(c log n)","category":"page"},{"location":"sorted_containers/#Inserting-and-Deleting-in-Sorted-Containers","page":"Sorted Containers","title":"Inserting & Deleting in Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"empty!(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument sc is a SortedDict, SortedMultiDict or SortedSet. This empties the container. Time: O(1).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"insert!(sc::SortedDict, k, v)","category":"page"},{"location":"sorted_containers/#Base.insert!-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.insert!","text":"insert!(sc, k)\n\nArgument sc is a SortedDict or SortedMultiDict, k is a key and v is the corresponding value. This inserts the (k,v) pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"insert!(sc::SortedMultiDict, k, v)","category":"page"},{"location":"sorted_containers/#Base.insert!-Tuple{SortedMultiDict, Any, Any}","page":"Sorted Containers","title":"Base.insert!","text":"insert!(sc, k)\n\nArgument sc is a SortedDict or SortedMultiDict, k is a key and v is the corresponding value. This inserts the (k,v) pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"insert!(sc::SortedSet, k)","category":"page"},{"location":"sorted_containers/#Base.insert!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.insert!","text":"insert!(sc, k)\n\nArgument sc is a SortedSet and k is a key. This inserts the key into the container. If the key is already present, this overwrites the old value. (This is not necessarily a no-op; see below for remarks about the customizing the sort order.) The return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"push!(sc::SortedSet, k)","category":"page"},{"location":"sorted_containers/#Base.push!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.push!","text":"push!(sc, k)\n\nArgument sc is a SortedSet and k is a key. This inserts the key into the container. If the key is already present, this overwrites the old value. (This is not necessarily a no-op; see below for remarks about the customizing the sort order.) The return value is sc. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"push!(sc::SortedDict, pr::Pair)","category":"page"},{"location":"sorted_containers/#Base.push!-Tuple{SortedDict, Pair}","page":"Sorted Containers","title":"Base.push!","text":"push!(sc, k=>v)\n\nArgument sc is a SortedDict or SortedMultiDict and k=>v is a key-value pair. This inserts the key-value pair into the container. If the key is already present, this overwrites the old value. The return value is sc. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"push!(sc::SortedMultiDict, pr::Pair)","category":"page"},{"location":"sorted_containers/#Base.push!-Tuple{SortedMultiDict, Pair}","page":"Sorted Containers","title":"Base.push!","text":"push!(sc, k=>v)\n\nArgument sc is a SortedDict or SortedMultiDict and k=>v is a key-value pair. This inserts the key-value pair into the container. If the key is already present, this overwrites the old value. The return value is sc. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"delete!((sc, st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Argument (sc,st) is a token for a SortedDict, SortedMultiDict or SortedSet. This operation deletes the item addressed by (sc,st). It is an error to call this on an entry that has already been deleted or on the before-start or past-end tokens. After this operation is complete, (sc,st) is an invalid token and cannot be used in any further operations. Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"pop!(sc::SortedDict, k)","category":"page"},{"location":"sorted_containers/#Base.pop!-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.pop!","text":"pop!(sc, k[, default])\n\nDeletes the item with key k in SortedDict or SortedSet sc and returns the value that was associated with k in the case of SortedDict or k itself in the case of SortedSet. If k is not in sc return default, or throw a KeyError if default is not specified. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"pop!(ss::SortedSet, k)","category":"page"},{"location":"sorted_containers/#Base.pop!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.pop!","text":"pop!(sc, k[, default])\n\nDeletes the item with key k in SortedDict or SortedSet sc and returns the value that was associated with k in the case of SortedDict or k itself in the case of SortedSet. If k is not in sc return default, or throw a KeyError if default is not specified. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"pop!(ss::SortedSet)","category":"page"},{"location":"sorted_containers/#Base.pop!-Tuple{SortedSet}","page":"Sorted Containers","title":"Base.pop!","text":"pop!(ss)\n\nDeletes the item with first key in SortedSet ss and returns the key. A BoundsError results if ss is empty. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"setindex!(m::SortedDict, d_, k_)","category":"page"},{"location":"sorted_containers/#Base.setindex!-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.setindex!","text":"sc[st] = v\n\nIf st is a semitoken and sc is a SortedDict or SortedMultiDict, then sc[st] refers to the value field of the (key,value) pair that the full token (sc,st) refers to. This expression may occur on either side of an assignment statement. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Token-Manipulation","page":"Sorted Containers","title":"Token Manipulation","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"compare(sc, st1, st2)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Here, st1 and st2 are semitokens for the same container sc; this function determines the relative positions of the data items indexed by (sc,st1) and (sc,st2) in the sorted order. The return value is -1 if (sc,st1) precedes (sc,st2), 0 if they are equal, and 1 if (sc,st1) succeeds (sc,st2). This function compares the tokens by determining their relative position within the tree without dereferencing them. For SortedDict it is mostly equivalent to comparing deref_key((sc,st1)) to deref_key((sc,st2)) using the ordering of the SortedDict except in the case that either (sc,st1) or (sc,st2) is the before-start or past-end token, in which case the deref operation will fail. Which one is more efficient depends on the time-complexity of comparing two keys. Similarly, for SortedSet it is mostly equivalent to comparing deref((sc,st1)) to deref((sc,st2)). For SortedMultiDict, this function is not equivalent to a key comparison since two items in a SortedMultiDict with the same key are not necessarily the same item. Time: O(log n)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"status((sc, st))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"This function returns 0 if the token (sc,st) is invalid (e.g., refers to a deleted item), 1 if the token is valid and points to data, 2 if the token is the before-start token and 3 if it is the past-end token. Time: O(1)","category":"page"},{"location":"sorted_containers/#Iteration-Over-Sorted-Containers","page":"Sorted Containers","title":"Iteration Over Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As is standard in Julia, iteration over the containers is implemented via calls to the iterate function. It is usual practice, however, to call this function implicitly with a for-loop rather than explicitly, so they are presented here in for-loop notation. Internally, all of these iterations are implemented with semitokens that are advanced via the advance operation. Each iteration of these loops requires O(log n) operations to advance the semitoken. If one loops over an entire container, then the amortized cost of advancing the semitoken drops to O(1).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The following snippet loops over the entire container sc, where sc is a SortedDict or SortedMultiDict:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for (k,v) in sc\n   < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In this loop, (k,v) takes on successive (key,value) pairs according to the sort order of the key. If one uses:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for p in sc\n   < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"where sc is a SortedDict or SortedMultiDict, then p is a k=>v pair.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"For SortedSet one uses:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for k in ss\n   < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"There are two ways to iterate over a subrange of a container. The first is the inclusive iteration for SortedDict and SortedMultiDict:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for (k,v) in inclusive(sc,st1,st2)\n  < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Here, st1 and st2 are semitokens that refer to the container sc. Token (sc,st1) may not be the before-start token and token (sc,st2) may not be the past-end token. It is acceptable for (sc,st1) to be the past-end token or (sc,st2) to be the before-start token or both (in these cases, the body is not executed). If compare(sc,st1,st2)==1 then the body is not executed. A second calling format for inclusive is inclusive(sc,(st1,st2)). With the second format, the return value of searchequalrange may be used directly as the second argument to inclusive.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"One can also define a loop that excludes the final item:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for (k,v) in exclusive(sc,st1,st2)\n  < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In this case, all the data addressed by tokens from (sc,st1) up to but excluding (sc,st2) are executed. The body is not executed at all if compare(sc,st1,st2)>=0. In this setting, either or both can be the past-end token, and (sc,st2) can be the before-start token. For the sake of consistency, exclusive also supports the calling format exclusive(sc,(st1,st2)). In the previous few snippets, if the loop object is p instead of (k,v), then p is a k=>v pair.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Both the inclusive and exclusive functions return objects that can be saved and used later for iteration. The validity of the tokens is not checked until the loop initiates.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"For SortedSet the usage is:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for k in inclusive(ss,st1,st2)\n  < body >\nend\n\nfor k in exclusive(ss,st1,st2)\n  < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"If sc is a SortedDict or SortedMultiDict, one can iterate over just keys or just values:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for k in keys(sc)\n   < body >\nend\n\nfor v in values(sc)\n   < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Finally, one can retrieve semitokens during any of these iterations. In the case of SortedDict and SortedMultiDict, one uses:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for (st,k,v) in semitokens(sc)\n    < body >\nend\n\nfor (st,k) in semitokens(keys(sc))\n    < body >\nend\n\nfor (st,v) in semitokens(values(sc))\n    < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In each of the above three iterations, st is a semitoken referring to the current (k,v) pair. In the case of SortedSet, the following iteration may be used:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for (st,k) in semitokens(ss)\n    < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"If one wishes to retrieve only semitokens, the following may be used:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for st in onlysemitokens(sc)\n    < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In this case, sc is a SortedDict, SortedMultiDict, or SortedSet. To be compatible with standard containers, the package also offers eachindex iteration:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"for ind in eachindex(sc)\n    < body >\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"This iteration function eachindex is equivalent to keys in the case of SortedDict. It is equivalent to onlysemitokens in the case of SortedMultiDict and SortedSet.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In place of sc in the above keys, values and semitokens, snippets, one could also use inclusive(sc,st1,st2) or exclusive(sc,st1,st2). Similarly, for SortedSet, one can iterate over semitokens(inclusive(ss,st1,st2)) or semitokens(exclusive(ss,st1,st2))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Note that it is acceptable for the loop body in the above semitokens code snippets to invoke delete!((sc,st)) or delete!((ss,st)). This is because the for-loop internal state variable is already advanced to the next token at the beginning of the body, so st is not necessarily referred to in the loop body (unless the user refers to it).","category":"page"},{"location":"sorted_containers/#Other-Functions","page":"Sorted Containers","title":"Other Functions","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"isempty(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Returns true if the container is empty (no items). Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"length(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Returns the length, i.e., number of items, in the container. Time: O(1)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"in(pr::Pair, m::SortedDict{K,D,Ord}) where {K,D,Ord <: Ordering}","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"in(x, iter)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Returns true if x is in iter, where iter refers to any of the iterable objects described above in the discussion of container loops and x is of the appropriate type. For all of the iterables except the five listed below, the algorithm used is a linear-time search. For example, the call:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"(k=>v) in exclusive(sd, st1, st2)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"where sd is a SortedDict, st1 and st2 are semitokens, k is a key, and v is a value, will loop over all entries in the dictionary between the two tokens and a compare for equality using isequal between the indexed item and k=>v.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The five exceptions are:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"(k=>v) in sd\n(k=>v) in smd\nk in ss\nk in keys(sd)\nk in keys(smd)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Here, sd is a SortedDict, smd is a SortedMultiDict, and ss is a SortedSet.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"These five invocations of in use the index structure of the sorted container and test equality based on the order object of the keys rather than isequal. Therefore, these five are all faster than linear-time looping. The first three were already discussed in the previous entry. The last two are equivalent to haskey(sd,k) and haskey(smd,k) respectively. To force the use of isequal test on the keys rather than the order object (thus slowing the execution from logarithmic to linear time), replace the above five constructs with these:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"(k=>v) in collect(sd)\n(k=>v) in collect(smd)\nk in collect(ss)\nk in collect(keys(sd))\nk in collect(keys(smd))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"eltype(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.eltype-Tuple{SortedDict}","page":"Sorted Containers","title":"Base.eltype","text":"eltype(sc)\n\nReturns the (key,value) type (a 2-entry pair, i.e., Pair{K,V}) for SortedDict and SortedMultiDict. Returns the key type for SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\neltype(sc)\n\nReturns the (key,value) type (a 2-entry pair, i.e., Pair{K,V}) for SortedDict and SortedMultiDict. Returns the key type for SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"keytype(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.keytype-Tuple{SortedDict}","page":"Sorted Containers","title":"Base.keytype","text":"keytype(sc)\n\nReturns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\nkeytype(sc)\n\nReturns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\nkeytype(sc)\n\nReturns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"valtype(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.valtype-Tuple{SortedDict}","page":"Sorted Containers","title":"Base.valtype","text":"valtype(sc)\n\nReturns the value type for SortedDict and SortedMultiDict. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"ordtype(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#DataStructures.ordtype-Tuple{SortedDict}","page":"Sorted Containers","title":"DataStructures.ordtype","text":"ordtype(sc)\n\nReturns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\nordtype(sc)\n\nReturns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\nordtype(sc)\n\nReturns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"orderobject(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#DataStructures.orderobject-Tuple{SortedDict}","page":"Sorted Containers","title":"DataStructures.orderobject","text":"orderobject(sc)\n\nReturns the order object used to construct the container. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"haskey(sc::SortedDict,k)","category":"page"},{"location":"sorted_containers/#Base.haskey-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.haskey","text":"haskey(sc,k)\n\nReturns true if key k is present for SortedDict, SortedMultiDict or SortedSet sc. For SortedSet, haskey(sc,k) is a synonym for in(k,sc). For SortedDict and SortedMultiDict, haskey(sc,k) is equivalent to in(k,keys(sc)). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"get(sd::SortedDict,k,v)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"get!(sd::SortedDict,k,v)","category":"page"},{"location":"sorted_containers/#Base.get!-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.get!","text":"get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => default, and return default.\n\nExamples\n\njulia> d = RobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nRobinDict{String, Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"getkey(sd::SortedDict,k,defaultk)","category":"page"},{"location":"sorted_containers/#Base.getkey-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.getkey","text":"getkey(sd,k,defaultk)\n\nReturns key k where sd is a SortedDict, if k is in sd else it returns defaultk. If the container uses in its ordering an eq method different from isequal (e.g., case-insensitive ASCII strings illustrated below), then the return value is the actual key stored in the SortedDict that is equivalent to k according to the eq method, which might not be equal to k. Similarly, if the user performs an implicit conversion as part of the call (e.g., the container has keys that are floats, but the k argument to getkey is an Int), then the returned key is the actual stored key rather than k. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"isequal(sc1::SortedDict,sc2::SortedDict)","category":"page"},{"location":"sorted_containers/#Base.isequal-Tuple{SortedDict, SortedDict}","page":"Sorted Containers","title":"Base.isequal","text":"isequal(sc1,sc2)\n\nChecks if two containers are equal in the sense that they contain the same items; the keys are compared using the eq method, while the values are compared with the isequal function. In the case of SortedMultiDict, equality requires that the values associated with a particular key have same order (that is, the same insertion order). Note that isequal in this sense does not imply any correspondence between semitokens for items in sc1 with those for sc2. If the equality-testing method associated with the keys and values implies hash-equivalence in the case of SortedDict, then isequal of the entire containers implies hash-equivalence of the containers. Time: O(cn + n log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"packcopy(sc::SortedDict)","category":"page"},{"location":"sorted_containers/#DataStructures.packcopy-Tuple{SortedDict}","page":"Sorted Containers","title":"DataStructures.packcopy","text":"packcopy(sc)\n\nThis returns a copy of sc in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\npackcopy(sc)\n\nThis returns a copy of sc in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\npackcopy(sc)\n\nThis returns a copy of sc in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"deepcopy(sc)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"This returns a copy of sc in which the data is deep-copied, i.e., the keys and values are replicated if they are mutable types. A semitoken for the original sc is a valid semitoken for the copy because this operation preserves the relative positions of the data in memory. Time O(maxn), where maxn denotes the maximum size that sc has attained in the past.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"packdeepcopy(sc)","category":"page"},{"location":"sorted_containers/#DataStructures.packdeepcopy-Tuple{Any}","page":"Sorted Containers","title":"DataStructures.packdeepcopy","text":"packdeepcopy(sc)\n\nThis returns a packed copy of sc in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\npackdeepcopy(sc)\n\nThis returns a packed copy of sc in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\npackdeepcopy(sc)\n\nThis returns a packed copy of sc in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"merge(m::SortedDict{K,D,Ord},\n               others::AbstractDict{K,D}...) where {K,D,Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#Base.merge-Union{Tuple{Ord}, Tuple{D}, Tuple{K}, Tuple{SortedDict{K, D, Ord}, Vararg{AbstractDict{K, D}}}} where {K, D, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.merge","text":"merge(sc1, sc2...)\n\nThis returns a SortedDict or SortedMultiDict that results from merging SortedDicts or SortedMultiDicts sc1, sc2, etc., which all must have the same key-value-ordering types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for keys shared between sc1 and sc2 the ordering is left-to-right. This function is not available for SortedSet, but the union function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"merge!(m::SortedDict{K,D,Ord},\n                others::AbstractDict{K,D}...) where {K,D,Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#Base.merge!-Union{Tuple{Ord}, Tuple{D}, Tuple{K}, Tuple{SortedDict{K, D, Ord}, Vararg{AbstractDict{K, D}}}} where {K, D, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.merge!","text":"merge!(sc, sc1...)\n\nThis updates sc by merging SortedDicts or SortedMultiDicts sc1, etc. into sc. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for overlapping keys the ordering is left-to-right. This function is not available for SortedSet, but the union! function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Set-operations","page":"Sorted Containers","title":"Set operations","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The SortedSet container supports the following set operations. Note that in the case of intersect, symdiff and setdiff, the two SortedSets should have the same key and ordering object. If they have different key or ordering types, no error message is produced; instead, the built-in default versions of these functions (that can be applied to Any iterables and that return arrays) are invoked.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"union!(m1::SortedSet, iterable_item)","category":"page"},{"location":"sorted_containers/#Base.union!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.union!","text":"union!(ss, iterable)\n\nThis function inserts each item from the second argument (which must iterable) into the SortedSet ss. The items must be convertible to the key-type of ss. Time: O(ci log n) where i is the number of items in the iterable argument.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"union(m1::SortedSet, others...)","category":"page"},{"location":"sorted_containers/#Base.union-Tuple{SortedSet, Vararg{Any}}","page":"Sorted Containers","title":"Base.union","text":"union(ss, iterable...)\n\nThis function creates a new SortedSet (the return argument) and inserts each item from ss and each item from each iterable argument into the returned SortedSet. Time: O(cn log n) where n is the total number of items in all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"intersect(m1::SortedSet{K,Ord}, others::SortedSet{K,Ord}...) where {K, Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#Base.intersect-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, Vararg{SortedSet{K, Ord}}}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.intersect","text":"intersect(ss, others...)\n\nEach argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(cn log n), where n is the total number of items in all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"symdiff(m1::SortedSet{K,Ord}, m2::SortedSet{K,Ord}) where {K, Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#Base.symdiff-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.symdiff","text":"symdiff(ss1, ss2)\n\nThe two argument are sorted sets with the same key and order type. This operation computes the symmetric difference, i.e., a sorted set containing entries that are in one of ss1, ss2 but not both. Time: O(cn log n), where n is the total size of the two containers.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"setdiff(m1::SortedSet{K,Ord}, m2::SortedSet{K,Ord}) where {K, Ord <: Ordering}","category":"page"},{"location":"sorted_containers/#Base.setdiff-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.setdiff","text":"setdiff(ss1, ss2)\n\nThe two arguments are sorted sets with the same key and order type. This operation computes the difference, i.e., a sorted set containing entries that in are in ss1 but not ss2. Time: O(cn log n), where n is the total size of the two containers.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"setdiff!(m1::SortedSet, iterable)","category":"page"},{"location":"sorted_containers/#Base.setdiff!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.setdiff!","text":"setdiff!(ss, iterable)\n\nThis function deletes items in ss that appear in the second argument. The second argument must be iterable and its entries must be convertible to the key type of m1. Time: O(cm log n), where n is the size of ss and m is the number of items in iterable.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"issubset(iterable, m2::SortedSet)","category":"page"},{"location":"sorted_containers/#Base.issubset-Tuple{Any, SortedSet}","page":"Sorted Containers","title":"Base.issubset","text":"issubset(iterable, ss)\n\nThis function checks whether each item of the first argument is an element of the SortedSet ss. The entries must be convertible to the key-type of ss. Time: O(cm log n), where n is the sizes of ss and m is the number of items in iterable.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Ordering-of-keys","page":"Sorted Containers","title":"Ordering of keys","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As mentioned earlier, the default ordering of keys uses isless and isequal functions. If the default ordering is used, it is a requirement of the container that isequal(a,b) is true if and only if !isless(a,b) and !isless(b,a) are both true. This relationship between isequal and isless holds for common built-in types, but it may not hold for all types, especially user-defined types. If it does not hold for a certain type, then a custom ordering argument must be defined as discussed in the next few paragraphs.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The name for the default ordering (i.e., using isless and isequal) is Forward. Note: this is the name of the ordering object; its type is ForwardOrdering. Another possible ordering object is Reverse, which reverses the usual sorted order. This name must be imported import Base.Reverse if it is used.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As an example of a custom ordering, suppose the keys are of type String, and the user wishes to order the keys ignoring case: APPLE, berry and Cherry would appear in that order, and APPLE and aPPlE would be indistinguishable in this ordering.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The simplest approach is to define an ordering object of the form Lt(my_isless), where Lt is a built-in type (see ordering.jl) and my_isless is the user's comparison function. In the above example, the ordering object would be:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Lt((x,y) -> isless(lowercase(x),lowercase(y)))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The ordering object is indicated in the above list of constructors in the o position (see above for constructor syntax).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"This approach may suffer from a performance hit because higher performance may be possible if an equality method is also available as well as a less-than method. A more complicated but higher-performance method to implement a custom ordering is as follows. First, the user creates a singleton type that is a subtype of Ordering as follows:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"struct CaseInsensitive <: Ordering\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Next, the user defines a method named lt for less-than in this ordering:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"lt(::CaseInsensitive, a, b) = isless(lowercase(a), lowercase(b))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The first argument to lt is an object of the CaseInsensitive type (there is only one such object since it is a singleton type). The container also needs an equal-to function; the default is:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"eq(o::Ordering, a, b) = !lt(o, a, b) && !lt(o, b, a)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The user can also customize this function with a more efficient implementation. In the above example, an appropriate customization would be:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"eq(::CaseInsensitive, a, b) = isequal(lowercase(a), lowercase(b))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Finally, the user specifies the unique element of CaseInsensitive, namely the object CaseInsensitive(), as the ordering object to the SortedDict, SortedMultiDict or SortedSet constructor.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"For the above code to work, the module must make the following declarations, typically near the beginning:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"import Base.Ordering\nimport Base.lt\nimport DataStructures.eq","category":"page"},{"location":"sorted_containers/#Cautionary-note-on-mutable-keys","page":"Sorted Containers","title":"Cautionary note on mutable keys","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As with ordinary Dicts, keys for the sorted containers can be either mutable or immutable. In the case of mutable keys, it is important that the keys not be mutated once they are in the container else the indexing structure will be corrupted. (The same restriction applies to Dict.) For example, suppose a SortedDict sd is defined in which the keys are of type Array{Int,1}. (For this to be possible, the user must provide an isless function or order object for Array{Int,1} since none is built into Julia.) Suppose the values of sd are of type Int. Then the following sequence of statements leaves sd in a corrupted state:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"k = [1,2,3]\nsd[k] = 19\nk[1] = 7","category":"page"},{"location":"sorted_containers/#Performance-of-Sorted-Containers","page":"Sorted Containers","title":"Performance of Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The sorted containers are currently not optimized for cache performance. This will be addressed in the future.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"There is a minor performance issue as follows: the container may hold onto a small number of keys and values even after the data records containing those keys and values have been deleted. This may cause a memory drain in the case of large keys and values. It may also lead to a delay in the invocation of finalizers. All keys and values are released completely by the empty! function.","category":"page"},{"location":"heaps/#Heaps","page":"Heaps","title":"Heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps are data structures that efficiently maintain the minimum (or maximum) for a set of data that may dynamically change.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"All heaps in this package are derived from AbstractHeap, and provide the following interface:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let `h` be a heap, `v` be a value, and `n` be an integer size\n\nlength(h)            # returns the number of elements\n\nisempty(h)           # returns whether the heap is empty\n\npush!(h, v)          # add a value to the heap\n\nfirst(h)             # return the first (top) value of a heap\n\npop!(h)              # removes the first (top) value, and returns it\n\nextract_all!(h)      # removes all elements and returns sorted array\n\nextract_all_rev!(h)  # removes all elements and returns reverse sorted array\n\nsizehint!(h, n)      # reserve capacity for at least `n` elements","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Mutable heaps (values can be changed after being pushed to a heap) are derived from AbstractMutableHeap <: AbstractHeap, and additionally provides the following interface:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let `h` be a heap, `i` be a handle, and `v` be a value.\n\ni = push!(h, v)            # adds a value to the heap and and returns a handle to v\n\nupdate!(h, i, v)           # updates the value of an element (referred to by the handle i)\n\ndelete!(h, i)              # deletes the node with handle i from the heap\n\nv, i = top_with_handle(h)  # returns the top value of a heap and its handle","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Currently, both min/max versions of binary heap (type BinaryHeap) and mutable binary heap (type MutableBinaryHeap) have been implemented.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Examples of constructing a heap:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryMinHeap{Int}()\nh = BinaryMaxHeap{Int}()             # create an empty min/max binary heap of integers\n\nh = BinaryMinHeap([1,4,3,2])\nh = BinaryMaxHeap([1,4,3,2])         # create a min/max heap from a vector\n\nh = MutableBinaryMinHeap{Int}()\nh = MutableBinaryMaxHeap{Int}()      # create an empty mutable min/max heap\n\nh = MutableBinaryMinHeap([1,4,3,2])\nh = MutableBinaryMaxHeap([1,4,3,2])  # create a mutable min/max heap from a vector","category":"page"},{"location":"heaps/#Using-alternate-orderings","page":"Heaps","title":"Using alternate orderings","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps can also use alternate orderings apart from the default one defined by Base.isless. This is accomplished by passing an instance of Base.Ordering as the first argument to the constructor. The top of the heap will then be the element that comes first according to this ordering.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The following example uses 2-tuples to track the index of each element in the original array, but sorts only by the data value:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"data = collect(enumerate([\"foo\", \"bar\", \"baz\"]))\n\nh1 = BinaryHeap(data) # Standard lexicographic ordering for tuples\nfirst(h1)             # => (1, \"foo\")\n\nh2 = BinaryHeap(Base.By(last), data) # Order by 2nd element only\nfirst(h2)                            # => (2, \"bar\")","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"If the ordering type is a singleton it can be passed as a type parameter to the constructor instead:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"BinaryHeap{T, O}()        # => BinaryHeap{T}(O())\nMutableBinaryHeap{T, O}() # => MutableBinaryHeap{T}(O())","category":"page"},{"location":"heaps/#Min-max-heaps","page":"Heaps","title":"Min-max heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Min-max heaps maintain the minimum and the maximum of a set, allowing both to be retrieved in constant (O(1)) time. The min-max heaps in this package are subtypes of AbstractMinMaxHeap <: AbstractHeap and have the same interface as other heaps with the following additions:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let h be a min-max heap, k an integer\nminimum(h)     # return the smallest element\nmaximum(h)     # return the largest element\n\npopmin!(h)     # remove and return the smallest element\npopmin!(h, k)  # remove and return the smallest k elements\n\npopmax!(h)     # remove and return the largest element\npopmax!(h, k)  # remove and return the largest k elements\n\npopall!(h)     # remove and return all the elements, sorted smallest to largest\npopall!(h, o)  # remove and return all the elements according to ordering o","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The usual first(h) and pop!(h) are defined to be minimum(h) and popmin!(h), respectively.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"This package includes an implementation of a binary min-max heap (BinaryMinMaxHeap).","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Atkinson, M.D., Sack, J., Santoro, N., & Strothotte, T. (1986). Min-Max > Heaps and Generalized Priority Queues. Commun. ACM, 29, 996-1000. doi: 10.1145/6617.6621","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Examples:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryMinMaxHeap{Int}()        # create an empty min-max heap with integer values\n\nh = BinaryMinMaxHeap([1, 2, 3, 4]) # create a min-max heap from a vector","category":"page"},{"location":"heaps/#Functions-using-heaps","page":"Heaps","title":"Functions using heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps can be used to extract the largest or smallest elements of an array without sorting the entire array first:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"data = [0,21,-12,68,-25,14]\nnlargest(3, data)  # => [68,21,14]\nnsmallest(3, data) # => [-25,-12,0]","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Both methods also support the by and lt keywords to customize the sort order, as in Base.sort:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"nlargest(3, data, by=x -> x^2)  # => [68,-25,21]\nnsmallest(3, data, by=x -> x^2) # => [0,-12,14]","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The lower-level DataStructures.nextreme function takes a Base.Ordering instance as the first argument and returns the first n elements according to this ordering:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"DataStructures.nextreme(Base.Forward, n, a) # Equivalent to nsmallest(n, a)","category":"page"},{"location":"heaps/#Improving-performance-with-Float-data","page":"Heaps","title":"Improving performance with Float data","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"One use case for custom orderings is to achieve faster performance with Float elements with the risk of random ordering if any elements are NaN. The provided DataStructures.FasterForward and DataStructures.FasterReverse orderings are optimized for this purpose and may achive a 2x performance boost:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryHeap{Float64, DataStructures.FasterForward}() # faster min heap\nh = BinaryHeap{Float64, DataStructures.FasterReverse}() # faster max heap\n\nh = MutableBinaryHeap{Float64, DataStructures.FasterForward}() # faster mutable min heap\nh = MutableBinaryHeap{Float64, DataStructures.FasterReverse}() # faster mutable max heap\n\nDataStructures.nextreme(DataStructures.FasterReverse(), n, a)  # faster nlargest(n, a)\nDataStructures.nextreme(DataStructures.FasterForward(), n, a)  # faster nsmallest(n, a)","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"robin_dict/#RobinDict","page":"RobinDict","title":"RobinDict","text":"","category":"section"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"RobinDict provides a standard dictionary, conforming to the AbstractDict protocol, which uses the Robin Hood hashing algorithm with backward-shift deletion to provide improved average performance over Dict.","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"The interface of RobinDict replicates that of Dict. This has an ordered version called OrderedRobinDict, which replicates the interface of OrderedDict.","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"Examples:","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"julia> d = RobinDict{Int, Char}(1 => 'a', 2 => 'b')\nRobinDict{Int64, Char} with 2 entries:\n  2 => 'b'\n  1 => 'a'\n\njulia> d[3] = 'c';\n\njulia> collect(d)\n3-element Vector{Pair{Int64, Char}}:\n 2 => 'b'\n 3 => 'c'\n 1 => 'a'\n\njulia> delete!(d, 2);\n\njulia> d[1]\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> d\nRobinDict{Int64, Char} with 2 entries:\n  3 => 'c'\n  1 => 'a'\n\njulia> pop!(d)\n3 => 'c'","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"DocTestSetup = nothing","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"splay_tree/#Splay-Tree","page":"Splay Tree","title":"Splay Tree","text":"","category":"section"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"The SplayTree type is an implementation of Splay Tree in Julia. It is a self-balancing binary search tree with the additional property that recently accessed elements are quick to access again. Operations such as search, insert and delete can be done in O(log n) amortized time, where n is the number of nodes in the SplayTree.","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"Examples:","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"julia> tree = SplayTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> haskey(tree, 3)\ntrue\n\njulia> tree[4]\n7\n\njulia> for k in 1:2:10\n           delete!(tree, k)\n       end\n\njulia> haskey(tree, 5)\nfalse","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"DocTestSetup = nothing","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"dibit_vector/#DiBitVector","page":"DiBitVector","title":"DiBitVector","text":"","category":"section"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"DiBitVector provides a memory-efficient vector of elements that represent four different values from 0 to 3. This structure is comparable to a BitVector in its performance and memory characteristics.","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"Examples:","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"julia> v = DiBitVector(4, 0)\n4-element DiBitVector:\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> w = DiBitVector(4, 2)\n4-element DiBitVector:\n 0x02\n 0x02\n 0x02\n 0x02\n\njulia> v[1] = 2\n2\n\njulia> v[2:4] .= 2\n3-element view(::DiBitVector, 2:4) with eltype UInt8:\n 0x02\n 0x02\n 0x02\n\njulia> v == w\ntrue\n\njulia> pop!(v)\n0x02\n\njulia> length(v)\n3","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"DocTestSetup = nothing","category":"page"},{"location":"accumulators/#Accumulators-and-Counters","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"A accumulator, as defined below, is a data structure that maintains an accumulated number for each key. This is a counter when the accumulated values reflect the counts:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"struct Accumulator{K, V<:Number}\n    map::Dict{K, V}\nend","category":"page"},{"location":"accumulators/#Constructors","page":"Accumulators and Counters","title":"Constructors","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"There are different ways to construct an accumulator/counter:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"a = Accumulator{K, V}()  # construct an accumulator with key-type K and\n                         # accumulated value type V\n\na = Accumulator(dict)    # construct an accumulator from a dictionary\n\na = counter(K)           # construct a counter, i.e. an accumulator with\n                         # key type K and value type Int\n\na = counter(dict)        # construct a counter from a dictionary\n\na = counter(seq)         # construct a counter by counting keys in a sequence\n\na = counter(gen)         # construct a counter by counting keys in a generator","category":"page"},{"location":"accumulators/#Usage","page":"Accumulators and Counters","title":"Usage","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"Usage of an accumulator/counter:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"# let a and a2 be accumulators/counters\n\na[x]             # get the current value/count for x,\n                 # if x was not added to a, it returns zero.\n\na[x] = v         # sets the current value/count for `x` to `v`\n\ninc!(a, x)       # increment the value/count for x by 1\ninc!(a, x, v)    # increment the value/count for x by v\n\ndec!(a, x)       # decrement the value/count for x by 1\ndec!(a, x, v)    # decrement the value/count for x by v\n\nreset!(a, x)     # remove a key x from a, and return its current value\n\nmerge!(a, a2)    # add all counts from a2 to a1\nmerge(a, a2)     # return a new accumulator/counter that combines the\n                 # values/counts in both a and a2\n                 # `a[v] + a2[v]` over all `v` in the universe","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"merge is the multiset sum operation (sometimes written ⊎).","category":"page"},{"location":"accumulators/#Use-as-a-multiset","page":"Accumulators and Counters","title":"Use as a multiset","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"An Accumulator{T, <:Integer} where T such as is returned by counter, is a multiset or Bag, of objects of type T. If the count type is not an integer but a more general real number, then this is a form of fuzzy multiset. We support a number of operations supporting the use of Accumulators as multisets.","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"Note that these operations will throw an error if the accumulator has negative or zero counts for any items.","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"\nsetdiff(a1, a2)          # The opposite of `merge` (i.e. multiset sum),\n                         # returns a new multiset with the count of items in `a2` removed from `a1`, down to a minimum of zero\n                         # `max(a1[v] - a2[v], 0)` over all `v` in the universe\n\n\nunion(a1, a2)            # multiset union (sometimes called maximum, or lowest common multiple)\n                         # returns a new multiset with the counts being the higher of those in `a1` or `a2`.\n                         # `max(a1[v], a2[v])` over all `v` in the universe\n\nintersect(a1, a2)        # multiset intersection (sometimes called infimum or greatest common divisor)\n                         # returns a new multiset with the counts being the lowest of those in `a1` or `a2`.\n                         # Note that this means things not occurring in both with be removed (count zero).\n                         # `min(a1[v], a2[v])` over all `v` in the universe","category":"page"},{"location":"linked_list/#Linked-List","page":"Linked List","title":"Linked List","text":"","category":"section"},{"location":"linked_list/","page":"Linked List","title":"Linked List","text":"A list of sequentially linked nodes. This allows efficient insertion of nodes to the front of the list:","category":"page"},{"location":"linked_list/","page":"Linked List","title":"Linked List","text":"julia> l1 = nil()\nnil()\n\njulia> l2 = cons(1, l1)\nlist(1)\n\njulia> l3 = list(2, 3)\nlist(2, 3)\n\njulia> l4 = cat(l1, l2, l3)\nlist(1, 2, 3)\n\njulia> l5 = map((x) -> x*2, l4)\nlist(2, 4, 6)\n\njulia> for i in l5; print(i); end\n246","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"priority-queue/#Priority-Queue","page":"Priority Queue","title":"Priority Queue","text":"","category":"section"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"The PriorityQueue type provides a basic priority queue implementation allowing for arbitrary key and priority types. Multiple identical keys are not permitted, but the priority of existing keys can be changed efficiently.","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"Usage:","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"PriorityQueue{K, V}()     # construct a new priority queue with keys of type K and priorities of type V (forward ordering by default)\nPriorityQueue{K, V}(ord)  # construct a new priority queue with the given types and ordering ord (Base.Order.Forward or Base.Order.Reverse)\nenqueue!(pq, k, v)        # insert the key k into pq with priority v\nenqueue!(pq, k=>v)        # (same, using Pairs)\ndequeue!(pq)              # remove and return the lowest priority key\ndequeue_pair!(pq)         # remove and return the lowest priorty key and value\npeek(pq)                  # return the lowest priority key and value without removing it\ndelete!(pq, k)            # delete the mapping for the given key in a priority queue, and return the priority queue.","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"PriorityQueue also behaves similarly to a Dict in that keys can be inserted and priorities accessed or changed using indexing notation.","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"Examples:","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"julia> # Julia code\n       pq = PriorityQueue();\n\njulia> # Insert keys with associated priorities\n       pq[\"a\"] = 10; pq[\"b\"] = 5; pq[\"c\"] = 15; pq\nPriorityQueue{Any, Any, Base.Order.ForwardOrdering} with 3 entries:\n  \"b\" => 5\n  \"a\" => 10\n  \"c\" => 15\n\njulia> # Change the priority of an existing key\n       pq[\"a\"] = 0; pq\nPriorityQueue{Any, Any, Base.Order.ForwardOrdering} with 3 entries:\n  \"a\" => 0\n  \"b\" => 5\n  \"c\" => 15","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"DocTestSetup = nothing","category":"page"},{"location":"ordered_containers/#OrderedDicts-and-OrderedSets","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"","category":"section"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"OrderedDicts are simply dictionaries whose entries have a particular order. For OrderedDicts (and OrderedSets), order refers to insertion order, which allows deterministic iteration over the dictionary or set:","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"d = OrderedDict{Char,Int}()\nfor c in 'a':'e'\n    d[c] = c-'a'+1\nend\ncollect(d) # => [('a',1),('b',2),('c',3),('d',4),('e',5)]\n\ns = OrderedSet(π,e,γ,catalan,φ)\ncollect(s) # => [π = 3.1415926535897...,\n           #     e = 2.7182818284590...,\n           #     γ = 0.5772156649015...,\n           #     catalan = 0.9159655941772...,\n           #     φ = 1.6180339887498...]","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"All standard Dict functions are available for OrderedDicts, and all Set operations are available for OrderedSets.","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"Note that to create an OrderedSet of a particular type, you must specify the type in curly-braces:","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"# create an OrderedSet of Strings\nstrs = OrderedSet{AbstractString}()","category":"page"},{"location":"circ_buffer/#CircularBuffer","page":"CircularBuffer","title":"CircularBuffer","text":"","category":"section"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"The CircularBuffer type implements a circular buffer of fixed capacity where new items are pushed to the back of the list, overwriting values in a circular fashion.","category":"page"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"Usage:","category":"page"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"cb = CircularBuffer{Int}(n)   # allocate an Int buffer with maximum capacity n\nisfull(cb)           # test whether the buffer is full\nisempty(cb)          # test whether the buffer is empty\nempty!(cb)           # reset the buffer\ncapacity(cb)         # return capacity\nlength(cb)           # get the number of elements currently in the buffer\nsize(cb)             # same as length(cb)\npush!(cb, 10)        # add an element to the back and overwrite front if full\npop!(cb)             # remove the element at the back\npushfirst!(cb, 10)   # add an element to the front and overwrite back if full\npopfirst!(cb)        # remove the element at the front\nappend!(cb, [1, 2, 3, 4])     # push at most last `capacity` items\nconvert(Vector{Float64}, cb)  # convert items to type Float64\neltype(cb)           # return type of items\ncb[1]                # get the element at the front\ncb[end]              # get the element at the back\nfill!(cb, data)      # grows the buffer up-to capacity, and fills it entirely, preserving existing elements.","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"red_black_tree/#Red-Black-Tree","page":"Red Black Tree","title":"Red Black Tree","text":"","category":"section"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"The RBTree type is an implementation of Red Black Tree in Julia. It is a self-balancing binary search tree with an extra bit of information, the color, in each of its node. Operations such as search, insert and delete can be done in O(log n) complexity, where n is the number of nodes in the RBTree.","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"Examples:","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"julia> tree = RBTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> haskey(tree, 3)\ntrue\n\njulia> tree[4]\n7\n\njulia> for k in 1:2:10\n           delete!(tree, k)\n       end\n\njulia> haskey(tree, 5)\nfalse","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"DocTestSetup = nothing","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"swiss_dict/#SwissDict","page":"SwissDict","title":"SwissDict","text":"","category":"section"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"SwissDict provides a standard dictionary, conforming to the AbstractDict protocol, which is inspired from SwissTable developed by Google. This provides improved performance over Dict at extremely high Load Factor.","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"The interface of SwissDict replicates that of Dict.","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"Examples:","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"julia> d = SwissDict(1 => 'a', 2 => 'b')\nSwissDict{Int64, Char} with 2 entries:\n  1 => 'a'\n  2 => 'b'\n\njulia> d[3] = 'c';\n\njulia> collect(d)\n3-element Vector{Pair{Int64, Char}}:\n 1 => 'a'\n 2 => 'b'\n 3 => 'c'\n\njulia> delete!(d, 2);\n\njulia> d[1]\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> d\nSwissDict{Int64, Char} with 2 entries:\n  1 => 'a'\n  3 => 'c'\n\njulia> pop!(d)\n1 => 'a'","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"DocTestSetup = nothing","category":"page"},{"location":"mutable_linked_list/#Mutable-Linked-List","page":"Mutable Linked List","title":"Mutable Linked List","text":"","category":"section"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"The MutableLinkedList type implements a doubly linked list with mutable nodes. This data structure supports constant-time insertion/removal of elements at both ends of the list.","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"Usage:","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"l = MutableLinkedList{T}()        # initialize an empty list of type T\nl = MutableLinkedList{T}(elts...) # initialize a list with elements of type T\nisempty(l)                        # test whether list is empty\nlength(l)                         # get the number of elements in list\ncollect(l)                        # return a vector consisting of list elements\neltype(l)                         # return type of list\nfirst(l)                          # return value of first element of list\nlast(l)                           # return value of last element of list\nl1 == l2                          # test lists for equality\nmap(f, l)                         # return list with f applied to elements\nfilter(f, l)                      # return list of elements where f(el) == true\nreverse(l)                        # return reversed list\ncopy(l)                           # return a copy of list\ngetindex(l, idx)   || l[idx]      # get value at index\ngetindex(l, range) || l[range]    # get values within range a:b\nsetindex!(l, data, idx)           # set value at index to data\nappend!(l1, l2)                   # attach l2 at the end of l1\nappend!(l, elts...)               # attach elements at end of list\ndelete!(l, idx)                   # delete element at index\ndelete!(l, range)                 # delete elements within range a:b\npush!(l, data)                    # add element to end of list\npushfirst!(l, data)               # add element to beginning of list\npop!(l)                           # remove element from end of list\npopfirst!(l)                      # remove element from beginning of list","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"MutableLinkedList implements the Iterator interface, iterating over the list from first to last.","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"DocTestSetup = :(using DataStructures)","category":"page"},{"location":"avl_tree/#AVL-Tree","page":"AVL Tree","title":"AVL Tree","text":"","category":"section"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"The AVLTree type is an implementation of AVL Tree in Julia. It is a self-balancing binary search tree where balancing occurs based on the difference of height of the left subtree and the right subtree. Operations such as search, insert and delete can be done in O(log n) complexity, where n is the number of nodes in the AVLTree. Order-statistics on the keys can also be done in O(log n).","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"Examples:","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"julia> tree = AVLTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> haskey(tree, 3)\ntrue\n\njulia> tree[4] # time complexity of this operation is O(log n)\n7\n\njulia> for k in 1:2:10\n           delete!(tree, k)\n       end\n\njulia> haskey(tree, 5)\nfalse\n\njulia> sorted_rank(tree, 17) # used for finding rank of the key\n4","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"DocTestSetup = nothing","category":"page"},{"location":"trie/#Trie","page":"Trie","title":"Trie","text":"","category":"section"},{"location":"trie/","page":"Trie","title":"Trie","text":"An implementation of the Trie data structure. This is an associative structure, with AbstractString keys:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"t = Trie{Int}()\nt[\"Rob\"] = 42\nt[\"Roger\"] = 24\nhaskey(t, \"Rob\")  # true\nget(t, \"Rob\", nothing)  # 42\nkeys(t)  # \"Rob\", \"Roger\"\nkeys(subtrie(t, \"Ro\"))  # \"b\", \"ger\"","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"Constructors:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"Trie(keys, values)                  # construct a Trie with the given keys and values\nTrie(keys)                          # construct a Trie{Void} with the given keys and with values = nothing\nTrie(kvs::AbstractVector{(K, V)})   # construct a Trie from the given vector of (key, value) pairs\nTrie(kvs::AbstractDict{K, V})       # construct a Trie from the given associative structure","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"This package also provides an iterator partial_path(t::Trie, str) for looping over all the nodes encountered in searching for the given string str. This obviates much of the boilerplate code needed in writing many trie algorithms. For example, to test whether a trie contains any prefix of a given string, use:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"seen_prefix(t::Trie, str) = any(v -> v.is_key, partial_path(t, str))","category":"page"},{"location":"#DataStructures.jl","page":"DataStructures.jl","title":"DataStructures.jl","text":"","category":"section"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"This package implements a variety of data structures, including","category":"page"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"Deque (implemented with an unrolled linked list)\nCircularBuffer\nCircularDeque (based on a circular buffer)\nStack\nQueue\nPriority Queue\nFenwick Tree\nAccumulators and Counters (i.e. Multisets / Bags)\nDisjoint Sets\nBinary Heap\nMutable Binary Heap\nOrdered Dicts and Sets\nRobinDict and OrderedRobinDict (implemented with Robin Hood Hashing)\nSwissDict (inspired from SwissTables)\nDictionaries with Defaults\nTrie\nLinked List and Mutable Linked List\nSorted Dict, Sorted Multi-Dict and Sorted Set\nDataStructures.IntSet\nSparseIntSet\nDiBitVector\nRed Black Tree\nAVL Tree\nSplay Tree","category":"page"},{"location":"#Contents","page":"DataStructures.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"Pages = [\n    \"index.md\",\n    \"deque.md\",\n    \"circ_buffer.md\",\n    \"circ_deque.md\",\n    \"stack_and_queue.md\",\n    \"priority-queue.md\",\n    \"fenwick.md\",\n    \"accumulators.md\",\n    \"disjoint_sets.md\",\n    \"heaps.md\",\n    \"ordered_containers.md\",\n    \"default_dict.md\",\n    \"robin_dict.md\",\n    \"trie.md\",\n    \"linked_list.md\",\n    \"mutable_linked_list.md\",\n    \"intset.md\",\n    \"sorted_containers.md\",\n    \"sparse_int_set.md\",\n    \"dibit_vector.md\",\n    \"red_black_tree.md\",\n    \"avl_tree.md\",\n    \"splay_tree.md\",\n]","category":"page"},{"location":"intset/#DataStructures.IntSet","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"","category":"section"},{"location":"intset/","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"DataStructures.IntSet is a drop-in replacement for the Base BitSet type. It efficiently stores dense collections of small non-negative Ints as a sorted set. The constructor IntSet([itr]) constructs a sorted set of the integers generated by the given iterable object, or an empty set if no argument is given. If the set will be sparse (for example holding a few very large integers), use Set or SortedSet instead.","category":"page"},{"location":"intset/","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"A complement IntSet may be constructed with complement or complement!. The complement of an empty IntSet contains typemax(Int) elements from 0 to typemax(Int)-1.","category":"page"},{"location":"fenwick/#Fenwick-Tree","page":"Fenwick Tree","title":"Fenwick Tree","text":"","category":"section"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"The FenwickTree type is data structures which is used for handling increment and decrement to prefix-sums of an array efficiently.","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"Usage:","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"FenwickTree{T}(n) # Constructs a Fenwick Tree of length `n`\nFenwickTree{T}(counts)  # Constructs a Fenwick Tree from an array of `counts`\ninc!(ft, ind, val)  # Increases the value of the FenwickTree `ft` by `val` from the index `ind` upto the length of `ft`\ndec!(ft, ind, val)  # Decreases the value of the FenwickTree `ft` by `val` from the index `ind` upto the length of `ft`\nincdec!(ft, left, right, val)  # Increases the value of the FenwickTree `ft` by `val` from the indices from `left` and decreases it from the `right`\nprefixsum(ft, ind)  # Return the cumulative sum from index 1 upto `ind` of the FenwickTree `ft`","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"Examples:","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"julia> f = FenwickTree{Int}(6)\njulia> inc!(f, 2, 5)\njulia> prefixsum(f, 1)\n 0\njulia> prefixsum(f, 3)\n 5","category":"page"}]
}
