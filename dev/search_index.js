var documenterSearchIndex = {"docs":
[{"location":"circ_deque/#CircularDeque","page":"CircularDeque","title":"CircularDeque","text":"","category":"section"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"The CircularDeque type implements a double-ended queue using a circular buffer of fixed capacity. This data structure supports constant-time insertion/removal of elements at both ends of a sequence.","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Usage:","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"a = CircularDeque{Int}(n)   # allocate a deque with maximum capacity n\nisempty(a)          # test whether the deque is empty\nempty!(a)           # reset the deque\ncapacity(a)         # return capacity\nlength(a)           # get the number of elements currently in the deque\npush!(a, 10)        # add an element to the back\npop!(a)             # remove an element from the back\npushfirst!(a, 20)   # add an element to the front\npopfirst!(a)        # remove an element from the front\nfirst(a)            # get the element at the front\nlast(a)             # get the element at the back\neltype(a)           # return type of items","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Note: Julia's Vector type also provides this interface, and thus can be used as a deque. However, the CircularDeque type in this package is implemented as a circular buffer, and thus avoids copying elements when modifications are made to the front of the vector.","category":"page"},{"location":"circ_deque/","page":"CircularDeque","title":"CircularDeque","text":"Benchmarks show that the performance of CircularDeque is several times faster than Deque.","category":"page"},{"location":"disjoint_sets/#Disjoint-Sets","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"","category":"section"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"Some algorithms, such as finding connected components in undirected graph and Kruskal's method of finding minimum spanning tree, require a data structure that can efficiently represent a collection of disjoint subsets. A widely used data structure for this purpose is the Disjoint set forest (disjoint sets).","category":"page"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"Usage:","category":"page"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"a = IntDisjointSet(10)  # creates a forest comprised of 10 singletons\nunion!(a, 3, 5)          # merges the sets that contain 3 and 5 into one and returns the root of the new set\nroot_union!(a, x, y)     # merges the sets that have root x and y into one and returns the root of the new set\nfind_root!(a, 3)         # finds the root element of the subset that contains 3\nin_same_set(a, x, y)     # determines whether x and y are in the same set\nelem = push!(a)          # adds a single element in a new set; returns the new element\n                         # (this operation is often called MakeSet)\nnum_groups(a)            # returns the number of sets","category":"page"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"One may also use other element types:","category":"page"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"a = DisjointSet{AbstractString}([\"a\", \"b\", \"c\", \"d\"])\nunion!(a, \"a\", \"b\")\nin_same_set(a, \"c\", \"d\")\npush!(a, \"f\")","category":"page"},{"location":"disjoint_sets/","page":"Disjoint-Sets","title":"Disjoint-Sets","text":"Note that the internal implementation of IntDisjointSet is based on vectors, and is very efficient. DisjointSet{T} is a wrapper of IntDisjointSet, which uses a dictionary to map input elements to an internal index. Note for DisjointSet, union!, root_union! and find_root! return the index of the root.","category":"page"},{"location":"deque/#Deque","page":"Deque","title":"Deque","text":"","category":"section"},{"location":"deque/","page":"Deque","title":"Deque","text":"A Deque (short for Double-ended Queue) is an abstract data type that generalizes a Queue for which elements can be added to or removed from both the front (head) and the back (tail) in O(1) time complexity.","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"The type Deque implements the Double-ended Queue as a list of fixed-size blocks using an unrolled linked list.","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"note: Note\nJulia's Vector type also provides this interface, and thus can be used as a deque. However, the Deque type in DataStructures.jl is implemented as a list of contiguous blocks (default size = 1 kilo-byte). As a Deque grows, new blocks are created and linked to existing blocks. This approach prevents copying operations that take place when growing a Vector.","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"Benchmark shows that the performance of Deque is comparable to Vector on push!, but is noticeably faster on pushfirst! (by about 30% to 40%).","category":"page"},{"location":"deque/#Constructors","page":"Deque","title":"Constructors","text":"","category":"section"},{"location":"deque/#DataStructures.Deque","page":"Deque","title":"DataStructures.Deque","text":"Deque{T}\nDeque{T}(blksize::Int) where T\n\nConstructs Deque object for elements of type T.\n\nParameters\n\nT::Type Deque element data type.\n\nblksize::Int Deque block size (in bytes). Default = 1024.\n\n\n\n\n\n","category":"type"},{"location":"deque/#Usage","page":"Deque","title":"Usage","text":"","category":"section"},{"location":"deque/","page":"Deque","title":"Deque","text":"The Deque implements the following methods:","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"==(x::Deque, y::Deque)\nempty!(d::Deque{T}) where T\nfirst(d::Deque)\nisempty(d::Deque)\nlast(d::Deque)\nlength(d::Deque)\npop!(d::Deque{T}) where T\npopfirst!(d::Deque{T}) where T\npush!(d::Deque{T}, x) where T\npushfirst!(d::Deque{T}, x) where T","category":"page"},{"location":"deque/","page":"Deque","title":"Deque","text":"","category":"page"},{"location":"deque/#Base.:==-Tuple{Deque, Deque}","page":"Deque","title":"Base.:==","text":"==(x::Deque, y::Deque)\n\nVerify if the deques x and y are equal in terms of their contents.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.empty!-Union{Tuple{Deque{T}}, Tuple{T}} where T","page":"Deque","title":"Base.empty!","text":"empty!(d::Deque{T}) where T\n\nReset the deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.first-Tuple{Deque}","page":"Deque","title":"Base.first","text":"first(d::Deque)\n\nReturns the first element of the deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.isempty-Tuple{Deque}","page":"Deque","title":"Base.isempty","text":"isempty(d::Deque)\n\nVerifies if deque d is empty.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.last-Tuple{Deque}","page":"Deque","title":"Base.last","text":"last(d::Deque)\n\nReturns the last element of the deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.length-Tuple{Deque}","page":"Deque","title":"Base.length","text":"length(d::Deque)\n\nReturns the number of elements in deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.pop!-Union{Tuple{Deque{T}}, Tuple{T}} where T","page":"Deque","title":"Base.pop!","text":"pop!(d::Deque{T}) where T\n\nRemove the element at the back of deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.popfirst!-Union{Tuple{Deque{T}}, Tuple{T}} where T","page":"Deque","title":"Base.popfirst!","text":"popfirst!(d::Deque{T}) where T\n\nRemove the element at the front of deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.push!-Union{Tuple{T}, Tuple{Deque{T}, Any}} where T","page":"Deque","title":"Base.push!","text":"push!(d::Deque{T}, x) where T\n\nAdd an element to the back of deque d.\n\n\n\n\n\n","category":"method"},{"location":"deque/#Base.pushfirst!-Union{Tuple{T}, Tuple{Deque{T}, Any}} where T","page":"Deque","title":"Base.pushfirst!","text":"pushfirst!(d::Deque{T}, x) where T\n\nAdd an element to the front of deque d.\n\n\n\n\n\n","category":"method"},{"location":"sparse_int_set/#DataStructures.SparseIntSet","page":"DataStructures.SparseIntSet","title":"DataStructures.SparseIntSet","text":"","category":"section"},{"location":"sparse_int_set/","page":"DataStructures.SparseIntSet","title":"DataStructures.SparseIntSet","text":"Implementation of a Sparse Integer Set, for background see Sparse Sets. Only positive non-zero Ints are allowed inside the set. The idea is to have one packed Vector storing all the Ints contained in the set as to allow for fast iteration, and a sparse, paged reverse Vector with the position of a particular Int inside the packed Vector. This allows for very fast iteration, insertion and deletion of indices. Most behavior is similar to a normal IntSet, however collect, first and last are with respected to the packed vector, in which the ordering is not guaranteed. The reverse Vector is paged, meaning that it is a Vector{Vector{Int}} where each of the Vector{Int}s has the length of one memory page of Ints. Every time an index that was not yet in the range of the already present pages, a new one will be created and added to the reverse, allowing for dynamical growth. Popping the last Int of a particular page will automatically clean up the memory of that page.","category":"page"},{"location":"default_dict/#DefaultDict-and-DefaultOrderedDict","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"","category":"section"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"A DefaultDict allows specification of a default value to return when a requested key is not in a dictionary.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"While the implementation is slightly different, a DefaultDict can be thought to provide a normal Dict with a default value. A DefaultOrderedDict does the same for an OrderedDict.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Constructors:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"DefaultDict(default, kv)    # create a DefaultDict with a default value or function,\n                            # optionally wrapping an existing dictionary\n                            # or array of key-value pairs\n\nDefaultDict{KeyType, ValueType}(default)   # create a DefaultDict with Dict type (KeyType,ValueType)\n\nDefaultOrderedDict(default, kv)     # create a DefaultOrderedDict with a default value or function,\n                                    # optionally wrapping an existing dictionary\n                                    # or array of key-value pairs\n\nDefaultOrderedDict{KeyType, ValueType}(default) # create a DefaultOrderedDict with Dict type (KeyType,ValueType)","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"All constructors also take a passkey::Bool=false keyword argument which determines whether to pass along the key argument when calling the default function. It has no effect when the key is just a value.","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Examples using DefaultDict:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict(1)               # create an (Any=>Any) DefaultDict with a default value of 1","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Int}(0)  # create a (AbstractString=>Int) DefaultDict with a default value of 0","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"d = Dict('a'=>1, 'b'=>2)\ndd = DefaultDict(0, d)            # provide a default value to an existing dictionary\nd['c']  # should raise a KeyError because 'c' key doesn't exist\ndd['c']","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultOrderedDict(time)     # call time() to provide the default value for an OrderedDict\ndd = DefaultDict(Dict)            # Create a dictionary of dictionaries - Dict() is called to provide the default value\ndd = DefaultDict(()->myfunc())    # call function myfunc to provide the default value","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"These all create the same default dict","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(() -> Vector{Int}())","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(() -> Int[])","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Vector{Int}}(Vector{Int})\n\npush!(dd[\"A\"], 1)\n\npush!(dd[\"B\"], 2)\n\ndd","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Create a Dictionary of type AbstractString=>DefaultDict{AbstractString, Int}, where the default of the inner set of DefaultDicts is zero","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, DefaultDict}(() -> DefaultDict{AbstractString,Int}(0))","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Use DefaultDict to cache an expensive function call, i.e., memoize","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, Int}(passkey=true) do key\n    len = length(key)\n    sleep(len)\n    return len\nend\n\ndd[\"hi\"]  # slow\n\ndd[\"ho\"]  # slow\n\ndd[\"hi\"]  # fast","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"Note that in the second-last example, we need to use a function to create each new DefaultDict. If we forget, we will end up using the sameDefaultDict for all default values:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"dd = DefaultDict{AbstractString, DefaultDict}(DefaultDict{AbstractString,Int}(0));\ndd[\"a\"]\ndd[\"b\"][\"a\"] = 1\ndd[\"a\"]","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"To create a DefaultDict which recursively calls itself you can write:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"rdict(args...) = DefaultDict(rdict, Dict{Any,Any}(args...))\ndd = rdict()\ndd[\"a\"][\"b\"][\"c\"]","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"It's also possible to create a recursive DefaultDict where the key is restricted:","category":"page"},{"location":"default_dict/","page":"DefaultDict and DefaultOrderedDict","title":"DefaultDict and DefaultOrderedDict","text":"rdict(args...) = DefaultDict{String,Any,typeof(rdict)}(rdict, Dict{String,Any}(args...))\ndd = rdict()\ndd[\"a\"][\"b\"][\"c\"]","category":"page"},{"location":"sorted_containers/#Sorted-Containers","page":"Sorted Containers","title":"Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Three sorted containers are provided: SortedDict, SortedMultiDict and SortedSet. SortedDict is similar to the built-in Julia type Dict with the additional feature that the keys are stored in sorted order and can be efficiently iterated in this order. SortedDict is a subtype of AbstractDict. It is generally slower than Dict because looking up a key requires an O(log n) tree search rather than an expected O(1) hash-table lookup time of Dict. SortedDict is a parameterized type with three parameters, the key type K, the value type V, and the ordering type O. SortedSet has only keys; it is an alternative to the built-in Set container and is a subtype of AbstractSet. Internally, SortedSet is implemented as a SortedDict in which the value type is Nothing. Finally, SortedMultiDict is similar to SortedDict except that each key can be associated with multiple values. The key=>value pairs in a SortedMultiDict are stored according to the sorted order for keys, and key=>value pairs with the same key are stored in order of insertion.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The containers internally use a 2-3 tree, which is a kind of balanced tree and is described in data structure textbooks.  Internally, one Vector is used to store key/data pairs (the leaves of the tree) while a second holds the tree structure.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The containers require two functions to compare keys: a less-than and equals function. With the default ordering argument, the comparison functions are isless(key1,key2) (true when key1 < key2) and isequal(key1,key2) (true when key1 == key2) where key1 and key2 are keys. More details are provided below.","category":"page"},{"location":"sorted_containers/#Tokens-for-Sorted-Containers","page":"Sorted Containers","title":"Tokens for Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The sorted containers support an object for indexing called a token defined as a two-entry tuple and aliased as SortedDictToken, SortedMultiDictToken, or SortedSetToken. A token is the address of a single data item in the container and can be dereferenced in time O(1).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The first entry of a token tuple is the container as a whole, and the second refers to the particular item. The second part is called a semitoken. The type of the semitoken is IntSemiToken.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"A restriction for the sorted containers is that IntSemiToken cannot used as the key-type. This is because ambiguity would result between the two subscripting calls sc[k] and sc[st] described below. In the rare scenario that a sorted container whose key-type is IntSemiToken is required, a workaround is to wrap the key inside another immutable structure.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The notion of token is similar to the concept of iterators used by C++ standard containers. Tokens can be explicitly advanced or regressed through the data in the sorted order; they are implicitly advanced or regressed via iteration defined below.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"A token may take two special values: the before-start value and the past-end value. These values act as lower and upper bounds on the actual data. The before-start token can be advanced, while the past-end token can be regressed. A dereferencing operation on either leads to an error.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In the current implementation, semitokens are internally stored as integers. Users should regard these integers as opaque since future versions of the package may change the internal indexing scheme. In certain situations it may be more costly to operate on tokens than semitokens because the first entry of a token (i.e., the container) is not a bits-type. If code profiling indicates that statements using tokens are allocating memory, then it may be advisable to rewrite the application code using semitokens rather than tokens.","category":"page"},{"location":"sorted_containers/#Complexity-of-Sorted-Containers","page":"Sorted Containers","title":"Complexity of Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"In the list of functions below, the running time of the various operations is provided. In these running times, n denotes the number of items in the container, and c denotes the time needed to compare two keys.","category":"page"},{"location":"sorted_containers/#Constructors-for-Sorted-Containers","page":"Sorted Containers","title":"Constructors for Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/#SortedDict-constructors","page":"Sorted Containers","title":"SortedDict constructors","text":"","category":"section"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict{K,V,Ord}(o::Ord=Forward) where {K, V, Ord <: Ordering}\nSortedDict{K,V,Ord}(o::Ord, kv) where {K, V, Ord <: Ordering}\n\nConstruct a SortedDict with key type K and value type V with o ordering from an iterable kv.  The iterable should generate either Pair{K,V} or Tuple{K,V}.  If omitted, then the SortedDict is initially empty.  Time: O(cn log n) where n is the length of the iterable.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(o::Ord=Forward) where {Ord <: Ordering}\nSortedDict{K,V}(o::Ord=Forward) where {K,V,Ord<:Ordering}\n\nConstruct an empty SortedDict with key type K and value type V with o ordering (default to forward ordering).  If K and V are not specified as in the first form, then they are assumed to both be Any. Time: O(1)\n\nNote that a key type of Any or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors in which the key type is inferred.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(iter, o::Ord=Forward) where {Ord <: Ordering}\nSortedDict(o::Ordering, iter)\nSortedDict{K,V}(iter, o::Ordering=Forward) where {K,V}\nSortedDict{K,V}(o::Ordering, iter) where {K,V}\n\nConstruct a SortedDict from an arbitrary iterable object of key=>value pairs or (key,value) tuples with order object o. The key type and value type are inferred from the given iterable in the first two forms.  The first two forms copy the data three times, so it is more efficient to explicitly specify K and V as in the second two forms.  Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedDict-Tuple{Vararg{Pair}}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict(ps::Pair...)\nSortedDict(o::Ordering, ps::Pair...)\nSortedDict{K,V}(ps::Pair...)\nSortedDict{K,V}(o::Ordering, ps::Pair...) where {K,V}\n\nConstruct a SortedDict from the given key-value pairs.  The key type and value type are inferred from the given key-value pairs in the first two forms. The ordering is assumed to be Forward ordering in the first and third form.   The first two forms (where K and V are not specified but inferred) involves copying the data three times  and so is less efficient than the second two forms. Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}","page":"Sorted Containers","title":"DataStructures.SortedDict","text":"SortedDict{K,V}(::Val{true}, iterable) where {K, V}\nSortedDict{K,V}(::Val{true}, iterable, ord::Ordering) where {K,V}\n\nConstruct a SortedDict from an iterable whose eltype is Tuple{K,V} or Pair{K,V} and that is already in sorted ordered.  The first form assumes Forward ordering.  No duplicate keys allowed.   Time: O(cn).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#SortedMultiDict-constructors","page":"Sorted Containers","title":"SortedMultiDict constructors","text":"","category":"section"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict{K,V,Ord}(o::Ord=Forward) where {K, V, Ord <: Ordering}\nSortedMultiDict{K,V,Ord}(o::Ord, iterable) where {K, V, Ord <: Ordering}\n\nConstruct a sorted multidict in which type parameters are explicitly listed; ordering object is explicitly specified.  Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(o::Ord=Forward) where {Ord <: Ordering}\nSortedMultiDict{K,V}(o::Ordering=Forward) where {K,V}\n\nConstruct an empty SortedMultiDict with key type K and value type V with o ordering (default to Forward ordering).  If K and V are not specified as in the first form, then they are assumed to both be Any. Time: O(1).\n\nNote that a key type of Any or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors in which the key type is inferred.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Tuple{Vararg{Pair}}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(ps::Pair...)\nSortedMultiDict(o, ps::Pair...)\nSortedMultiDict{K,V}(ps::Pair...)\nSortedMultiDict{K,V}(o, ps::Pair...)\n\nConstruct a SortedMultiDict from the given key-value pairs.  The key type and value type are inferred from the given key-value pairs in the first two form. The ordering is assumed to be Forward ordering in the first and third forms.   The first two forms involve copying the data three times to infer the types and so are less efficient than the third and fourth form where {K,V} are specified explicitly.  Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict(iter, o::Ord=Forward) where {Ord <: Ordering}\nSortedMultiDict(o::Ordering, iter)\nSortedMultiDict{K,V}(iter, o::Ordering=Forward) where {K, V}\nSortedMultiDict{K,V}(o::Ordering, iter) where {K, V}\n\nConstruct a SortedMultiDict from an arbitrary iterable object of key=>value pairs or (key,value) tuples with order object o. The key type and value type are inferred from the given iterable in the first two forms.  The first two forms copy the data three times, so it is more efficient to explicitly specify K and V as in the second two forms.  Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedMultiDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}","page":"Sorted Containers","title":"DataStructures.SortedMultiDict","text":"SortedMultiDict{K,V}(::Val{true}, iterable) where {K,V}\nSortedMultiDict{K,V}(::Val{true}, iterable, ord::Ord) where {K,V,Ord<:Ordering}\n\nConstruct a SortedMultiDict from an iterable whose eltype is Tuple{K,V} or Pair{K,V} and that is already in sorted ordered.  The first form assumes Forward ordering. Duplicate keys allowed. Time: O(cn).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#SortedSet-constructors","page":"Sorted Containers","title":"SortedSet constructors","text":"","category":"section"},{"location":"sorted_containers/#DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}, Tuple{K}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet{K,Ord}(o::Ord=Forward) where {K, Ord<:Ordering}\nSortedSet{K,Ord}(o::Ord, iter) where {K, Ord<:Ordering}\n\nConstruct a SortedSet of eltype Kusing from elements produced by  iterable iter (e.g., an array) and ordering object o.  Running time: O(cn log n) where n is the length of iterable.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}} where Ord<:Base.Order.Ordering","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet(o::Ord=Forward) where {Ord <: Ordering}\nSortedSet{K}(o::Ord=Forward) where {K, Ord<:Ordering}\n\nConstruct an empty SortedSet with Forward ordering.  The first form assumes element type of Any.  Time: O(1).\n\nNote that an element type of Any or any other abstract type will lead to slow performance.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedSet-Tuple{Base.Order.Ordering, Any}","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet(o::Ordering, iter)\nSortedSet(iter, o::Ordering=Forward)\nSortedSet{K}(o::Ordering, iter)\nSortedSet{K}(iter, o::Ordering=Forward)\n\nConstruct a sorted set from an iterable iter using order o.   In the first two forms, the element type is inferred from the iterable, which requires copying the data twice.  Therefore, the second two forms (specifying K explicitly) are more efficient. Time: O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.SortedSet-Union{Tuple{K}, Tuple{Val{true}, Any}} where K","page":"Sorted Containers","title":"DataStructures.SortedSet","text":"SortedSet{K}(::Val{true}, iterable) where {K}\nSortedSet{K}(::Val{true}, iterable, ord::Ord) where {K, Ord <: Ordering}\n\nConstruct a SortedSet from an iterable whose entries have type K and that is already in sorted ordered. No duplicates allowed.  The first form assumes Forward ordering. Time: O(cn).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Navigating-the-Containers","page":"Sorted Containers","title":"Navigating the Containers","text":"","category":"section"},{"location":"sorted_containers/#Base.getindex-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.getindex","text":"Base.getindex(sd::SortedDict, k)\n\nRetrieve the value associated with key k in SortedDict sc. Yields a KeyError if k is not found.   The following functions do not throw an error if the key is not found: Base.get(sd::SortedDict,k,v) and findkey(sd::SortedDict, k). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.getindex-Tuple{SortedDict, DataStructures.Tokens.IntSemiToken}","page":"Sorted Containers","title":"Base.getindex","text":"Base.getindex(m::SortedDict, st::IntSemiToken)\nBase.getindex(m::SortedMultiDict, st::IntSemiToken)\n\nRetrieve value portion of item from SortedDict or SortedMultiDict m indexed by st, a semitoken. Notation m[st] appearing in  an expression is equivalent to deref_value(token::Token) where token=(m,st).   It is a BoundsError if the token is invalid.  Prepending with @inbounds may elide the correctness check and results in undefined behavior if the token is invalid. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.setindex!-Tuple{SortedDict, Any, DataStructures.Tokens.IntSemiToken}","page":"Sorted Containers","title":"Base.setindex!","text":"Base.setindex!(m::SortedDict, newvalue, st::IntSemiToken)\nBase.setindex!(m::SortedMultiDict, newvalue, st::IntSemiToken)\n\nSet the value portion of item from SortedDict or SortedMultiDict m indexed by st, a semitoken to newvalue.   A BoundsError is thrown if the token is invalid. Prepending with @inbounds may elide the correctness check and results in undefined behavior if the token is invalid. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.setindex!-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.setindex!","text":"Base.setindex!(sd::SortedDict, newvalue, k)\n\nAssign or reassign the value associated with the key k to newvalue.  Note that the key is also overwritten; this is not necessarily a no-op since the equivalence in the sort-order does not imply equality. See also push_return_semitoken!(sd::SortedDict, p::Pair). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.deref-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.deref","text":"deref(token::Token)\nderef((m,st))\n\nReturn the data item indexed by the token.  If the container is a SortedSet, then this is a key in the set. If the container is a SortedDict or SortedMultiDict, then this is a key=>value pair.  It is a BoundsError if the token is invalid or is the before-start or past-end token.   Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a  sorted container m  and a semitoken st.  Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.deref_key-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.deref_key","text":"deref_key(token::Token)\nderef_key((m,st))\n\nReturn the key portion of a data item (a key=>value pair) in a  SortedDict or SortedMultiDict indexed by the token. It is a BoundsError if the token is invalid or is the before-start or past-end token.  Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a container m  and a semitoken st.  Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.deref_value-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.deref_value","text":"deref_value(token::Token)\nderef_value((m,st))\n\nReturns the value portion of a data item (a key=>value pair) in a SortedDict or SortedMultiDict  indexed by the token.  It is a BoundsError if the token is invalid or is the before-start or past-end token.  Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a container m  and a semitoken st.  Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.firstindex","text":"Base.firstindex(m::SortedContainer)\n\nReturn the semitoken of the first entry of the container m, or the past-end semitoken if the container is empty.  This function was called startof (now deprecated) in previous versions of the package. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.lastindex","text":"Base.lastindex(m::SortedContainer)\n\nReturn the semitoken of the last entry of the sorted container m, or the before-start semitoken if the container is empty.   This function was called endof (now deprecated) in previous versions of the package. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.token_firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.token_firstindex","text":"token_firstindex(m::SortedContainer)\n\nReturn the token of the first entry of the sorted container m, or the past-end token if the container is empty.  Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.token_lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.token_lastindex","text":"token_lastindex(m::SortedContainer)\n\nReturn the token of the last entry of the sorted container m, or the before-start semitoken if the container is empty.  Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.first-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.first","text":"Base.first(sc::SortedContainer)\n\nReturn the  first item (a k=>v pair for SortedDict and SortedMultiDict or an element for SortedSet) in sc according to the sorted order in the container. It is a BoundsError to call this function on an empty container.  Equivalent to deref(token_startindex(sc)). Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.last-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.last","text":"Base.last(sc::SortedContainer)\n\nReturn the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) in sc according to the sorted order in the container. It is a BoundsError to call this function on an empty container. Equivalent to deref(token_lastindex(sc)). Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.pastendsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.pastendsemitoken","text":"pastendsemitoken(m::SortedContainer)\n\nReturn the semitoken of the entry that is one past the end of the sorted container m. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.beforestartsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.beforestartsemitoken","text":"beforestartsemitoken(m::SortedContainer)\n\nReturn the semitoken of the entry that is one before the beginning of the  sorted container m.  Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.pastendtoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.pastendtoken","text":"pastendtoken(m::SortedContainer)\n\nReturn the token of the entry that is one past the end of the sorted container m. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.beforestarttoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.beforestarttoken","text":"beforestarttoken(m::SortedContainer)\n\nReturn the token of the entry that is one before the beginning of the  sorted container m. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.advance-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.advance","text":"advance(token::Token)\nadvance((m,st))\n\nReturn the semitoken of the item in a sorted container one after the given token.  A BoundsError is thrown if the token is the past-end token.   Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid or points to the past-end token. The second form creates the token in-place as a tuple of a  container m and a semitoken st. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.regress-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.regress","text":"regress(token::Token)\nregress((m,st))\n\nReturn the semitoken of the item in a sorted container one before the given token.  A BoundsError is thrown if the token is the before-start token.   Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start token. The second form creates the token in-place as a tuple of a container m and a semitoken st. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.:+-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}, Integer}","page":"Sorted Containers","title":"Base.:+","text":"Base.+(t::Token, j::Integer)\nBase.-(t::Token, j::Integer)\n\nReturn the token that is j positions ahead (if +) or behind (if -) of t. Here, t is a token for a sorted container and j is an integer.  If j is negative, then + regresses while - advances. If the operation t+j or t-j reaches the before-start  or past-end positions in the container, then the before-start/past-end tokens are returned (and there is no error). Time: O(j+log n), so this function is not optimized for long jumps.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.Sort.searchsortedfirst-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}","page":"Sorted Containers","title":"Base.Sort.searchsortedfirst","text":"Base.searchsortedfirst(m::SortedContainer, k)\n\nReturn the semitoken of the first item in the  sorted container m that is greater than or equal to k in the sort order. If there is no such item, then the past-end semitoken is returned.  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.Sort.searchsortedlast-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}","page":"Sorted Containers","title":"Base.Sort.searchsortedlast","text":"Base.searchsortedlast(m::SortedContainer, k)\n\nReturn the semitoken of the last item in the container that is less than or equal to k in sort order.  If there is no such item, then the before-start semitoken is returned.  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.searchsortedafter-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}","page":"Sorted Containers","title":"DataStructures.searchsortedafter","text":"searchsortedafter(m::SortedContainer, k)\n\nReturn the semitoken of the first item in the container that is greater than k in the sort order.  If there is no such item, then the past-end semitoken is returned. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.searchequalrange-Tuple{SortedMultiDict, Any}","page":"Sorted Containers","title":"DataStructures.searchequalrange","text":"DataStructures.searchequalrange(smd::SortedMultiDict, k)\n\nReturn two semitokens that correspond to the first and last items in the SortedMultiDict that have key exactly equal to k.  If k is not found, then it returns  (pastendsemitoken(smd), beforestartsemitoken(smd)). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.findkey-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"DataStructures.findkey","text":"findkey(m::SortedSet, k)\n\nReturn the semitoken of the element k in sorted set m. If the element is not present in m, then the past-end semitoken is returned.  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.findkey-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"DataStructures.findkey","text":"DataStructures.findkey(sd::SortedDict, k)\n\nReturn the semitoken that  points to the item whose key is k, or past-end semitoken if k is absent.  See also  Base.getindex(sd::SortedDict, k) Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Inserting-and-Deleting-in-Sorted-Containers","page":"Sorted Containers","title":"Inserting & Deleting in Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/#Base.push!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.push!","text":"Base.push!(ss::SortedSet, k)\n\nInsert the element k into the sorted set ss. If the k is already present, this overwrites the old value. (This is not necessarily a no-op; see remarks about the  customizing the sort order.)  See also push_return_semitoken!(ss::SortedSet, k). The return value is ss. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.push!-Tuple{SortedDict, Pair}","page":"Sorted Containers","title":"Base.push!","text":"Base.push!(sd::SortedDict, p::Pair)\n\nInsert key-value pair p, i.e., a k=>v pair, into sd. If the key k is already present, this overwrites the old value.  The key is also overwritten (not necessarily a no-op, since  sort-order equivalence may differ from equality). The return value is sd.   See also push_return_semitoken!(sd::SortedDict, p::Pair). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.push!-Tuple{SortedMultiDict, Pair}","page":"Sorted Containers","title":"Base.push!","text":"Base.push!(smd::SortedMultiDict, p::Pair)\n\nInsert the pair p, i.e., a k=>v into smd. If k already appears as a key in smd, then k=>v is inserted in the rightmost position after existing items with key k.  Returns the container. See also push_return_semitoken!(smd::SortedMultiDict, p::Pair). Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.push_return_semitoken!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"DataStructures.push_return_semitoken!","text":"DataStructures.push_return_semitoken!(ss::SortedSet, k)\n\nInsert the element k into the SortedSet sc. If k is already present, this overwrites the old value. (This is not necessarily a no-op; see remarks about the  customizing the sort order.) Unlike push!, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry.   This function replaces the deprecated insert!. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.push_return_semitoken!-Tuple{SortedDict, Pair}","page":"Sorted Containers","title":"DataStructures.push_return_semitoken!","text":"DataStructures.push_return_semitoken!(sd::SortedDict, p::Pair)\n\nInsert pair p of the form k=>v into sd. If the key is already present in sd, this overwrites the old value. Note that the key is also overwritten, which is not necessarily a no-op because equivalence in the sort order does not necessarily imply equality.  Unlike push!, the return value is a 2-tuple whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and whose second entry is the semitoken of the new entry. This function replaces the deprecated insert!(sd,k,v).  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.push_return_semitoken!-Tuple{SortedMultiDict, Pair}","page":"Sorted Containers","title":"DataStructures.push_return_semitoken!","text":"DataStructures.push_return_semitoken!(smd::SortedMultiDict, pr::Pair)\n\nInsert the key-value pair pr, i.e., k=>v, into smd.   If k already appears as a key in smd, then k=>v is inserted in the rightmost position after existing items with key k.  Unlike push!,  the return value is a 2-tuple whose first entry is boolean always equal to true and whose second entry is the semitoken of the new entry. (The reason for returning a bool whose value is always true is for consistency with push_return_semitoken! for SortedDict and SortedSet.) This function replaces the deprecated insert!. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.delete!-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"Base.delete!","text":"Base.delete!(token::Token)\n\nDelete the item indexed by the token from a sorted container.   A BoundsError is thrown if the token is invalid. Prepending with @inbounds may elide the correctness check and will result in undefined behavior if the token is invalid. Time: O(log n).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.delete!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.delete!","text":"Base.delete!(ss::SortedSet, k)\n\nDelete element k from sc.  After this operation is complete, a token addressing the deleted item is invalid. Returns sc.  if k is not present, this operation is a no-op. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.delete!-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.delete!","text":"Base.delete!(sd::SortedDict, k)\n\nDelete the item whose key is k in sd. After this operation is complete, any token addressing the deleted item is invalid. Returns sc.  This is a no-op if k is not present in sd.  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.pop!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.pop!","text":"Base.pop!(ss::SortedSet, k)\nBase.pop!(ss::SortedSet, k, default)\n\nDelete the item with key k in ss and return the item that compares equal to k according to the sort order (which is not necessarily k, since equality in the sort-order does not necessarily imply hash-equality). If k is not found, return default, or throw a KeyError if default is not specified. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.pop!-Tuple{SortedDict, Any}","page":"Sorted Containers","title":"Base.pop!","text":"Base.pop!(sd::SortedDict, k)\nBase.pop!(sd::SortedDict, k, default)\n\nDelete the item with key k in sd and return the value that was associated with k. If k is not in sd return default, or throw a KeyError if default is not specified. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.popfirst!-Tuple{SortedSet}","page":"Sorted Containers","title":"Base.popfirst!","text":"Base.popfirst!(ss::SortedSet)\n\nDelete the item with first key in SortedSet ss and returns the key.  This function was named pop! in a previous version of the package.  A BoundsError results if ss is empty. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.poplast!-Tuple{SortedSet}","page":"Sorted Containers","title":"DataStructures.poplast!","text":"poplast!(ss::SortedSet)\n\nDelete the item with last key in SortedSet ss and returns the key. A BoundsError results if ss is empty.   This function will be renamed Base.pop! in a future version of the package. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Iteration-and-Token-Manipulation","page":"Sorted Containers","title":"Iteration and Token Manipulation","text":"","category":"section"},{"location":"sorted_containers/#DataStructures.compare-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken, DataStructures.Tokens.IntSemiToken}","page":"Sorted Containers","title":"DataStructures.compare","text":"compare(m::SortedContainer, s::IntSemiToken, t::IntSemiToken)\n\nDetermine the  relative position according to the sort order of the  data items indexed by tokens (m,s) and  (m,t).  Return:\n\n-1if(m,s) precedes (m,t), \n0 if s == t \n1 if (m,s)succeeds (m,t). \n\nThe relative positions are determined  from the tree topology without any key comparisons. Time: O(log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.status-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}","page":"Sorted Containers","title":"DataStructures.status","text":"status(token::Token) \nstatus((m, st))\n\nDetermine the status of a token.  Return values are:\n\n0 = invalid token\n1 = valid and points to live data\n2 = before-start token\n3 = past-end token\n\nThe second form creates the token in-place as a tuple of a sorted container m and a semitoken st. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.iterate-Tuple{Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.iterate","text":"Base.iterate(iter::SortedContainerIterable)\n\nwith the following helper functions to construct a SortedContainerIterable:\n\ninclusive(m::SortedContainer, st1, st2)\ninclusive(m::SortedContainer, (st1, st2))\ninclusive_key(m::SortedContainer, key1, key2)\ninclusive_key(m::SortedContainer, (key1, key2))\nexclusive(m::SortedContainer, st1, st2)\nexclusive(m::SortedContainer, (st1, st2))\nexclusive_key(m::SortedContainer, key1, key2)\nexclusive_key(m::SortedContainer, (key1, key2))\nBase.keys(b)\nBase.values(b)\nBase.pairs(b)\nBase.eachindex(b)\ntokens(kv)\nsemitokens(kv)\nonlytokens(kv)\nonlysemitokens(kv)\nBase.Iterators.reverse(m)\n(:)(a,b)\n\nIterate over a sorted container, typically  within a for-loop, comprehension, or generator. Here, iter is an iterable object constructed from a sorted container.  The possible iterable objects are constructed from the helper functions as follows:\n\nA basic iterable object is either \n\nan entire sorted container m,\ninclusive(m, (st1, st2)) or equivalently inclusive(m, st1, st2), \ninclusive_key(m, (k1, k2)) or equivalently inclusive_key(m, k1, k2)\na:b, where a and b are tokens addressing the same container\nexclusive(m, (st1, st2)) or equivalently exclusive(m, st1, st2)\nexclusive_key(m, (k1, k2)) or equivalently exclusive_key(m, k1, k2)\n\nThese extract ranges of consecutive items in the containers.  In the inclusive and exclusive constructions, constructions, m is a container, st1 and st2 are semitokens.  The inclusive range includes both endpoints st1 and st2.  The inclusive  iteration is empty if compare(m,st1,st2)<0. The exclusive range includes endpoint st1 but not st2.  The exclusive iteration is empty if compare(m,st1,st2)<=0.  In the exclusive iteration, it is acceptable if st2 is the past-end semitoken.  \n\nThe range exclusive_key means all data items with keys between k1 up to but excluding items with key k2.  For this range to be nonempty,  k1<k2 must hold (in the sort order).   The range inclusive_key means all data items with keys between k1 and k2 inclusive.  For this range to be nonempty, k1<=k2 must hold.\n\nA kv iterable object has the form \n\nb, a basic iterable object\nkeys(b) where b is a basic object.  Extract keys only (not applicable  to SortedSet)\nvalues(b) where b is a basic object.  Extract values only  (not applicable to SortedSet).\npairs(b) where b is a basic object. Extracts key=>value pairs  (not applicable to SortedSet).    This is the same as just specifying b and is provided only for compatibility  with Base.pairs.  \n\nA tkv object has the form \n\nkv, a kv iterable object\ntokens(kv) where kv is a kv iterable object.    Return 2-tuples of the form (t,w), where t is the  token of the item and w is a key or value if kv is a keys or values  iteration, or (t,k,v) if kv is a pairs iteration. \nsemitokens(kv) where kv is a kv iterable object.    Return pairs of the form (st,w), where st is the  token of the item and w is a key or value if kv is a keys or values  iteration, or (st,k,v) if kv is a pairs iteration.\nonlytokens(kv) where kv is a kv iterable object. Return only tokens  of the data items but not the items themselves.    The keys, values, or pairs modifiers described above  are ignored.\nonlysemitokens(kv) where kv is a kv iterable object. Return only semitokens  of the data items but not the items themselves.    The keys, values, or pairs modifiers described above  are ignored.\n\nFinally, a tkv iteration can be reversed by the Iterators.reverse function.  The Iterators.reverse function may be nested in an arbitrary position with respect to the other operations described  above. Two reverse operations cancel each other out.  For example, Iterators.reverse(keys(Iterators.reverse(m))) is the same iteration as keys(m).\n\nFor compatibility with Base, there is also an eachindex function: eachindex(b) where the base object b a SortedDict is the same as keys(b) (to be compatible with Dict).   On the other hand, eachindex(b) where the base object b is a SortedSet or SortedMultiDict is the same as onlysemitokens(b).\n\nColon notation a:b  is equivalent to onlytokens(inclusive(a[1], a[2], b[2])), in other words, it yields an iteration that provides all the tokens of items in the sort order ranging from token a up to token b. It is required that a[1]===b[1] (i.e., a and b are tokens for the same container).  Exclusive iteration using colon notation is obtained via a : b-1.\n\nExamples:\n\n   for (k,v) in sd\n       <body>\n   end\n\nHere, sd is a SortedDict or SortedMultiDict.  The variables (k,v)  are set to consecutive key-value pairs.  All items in the container are produced in order.\n\n   for k in inclusive(ss, st1, st2)\n       <body>\n   end\n\nHere, ss is a SortedSet, and st1, and st2 are semitokens indexing ss. The elements of the set between st1 and st2 inclusive are returned.\n\n   for (t,k) in tokens(keys(exclusive_key(sd, key1, key2)))\n      <body>\n   end\n\nHere, sd is a SortedDict or SortedMultiDict, key1 and key2 are keys indexing sd.  In this case, t will be tokens of consecutive items, while k will be the corresponding keys.  The returned keys lie between key1 and key2 excluding key2.\n\n   for (t,k) in Iterators.reverse(tokens(keys(exclusive_key(sd, key1, key2))))\n      <body>\n   end\n\nSame as above, except the iteration is in the reverse order.\n\nWriting on the objects returned by values is not currently supported, e.g., the following map! statement is not implemented even though the  analogous statement is available for Dict in Base.\n\n    s = SortedDict(3=>4)\n    map!(x -> x*2, values(s))\n\nThe workaround is an explicit loop:\n\n    s = SortedDict(3=>4)\n    for t in onlysemitokens(s)\n        s[t] *= 2\n    end\n\nRunning time for all iterations: O(c(s + log n)), where s is the number of steps from start to end of the iteration.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.in-Tuple{Any, SortedSet}","page":"Sorted Containers","title":"Base.in","text":"Base.in(k,m::SortedSet)\n\nReturn true iff element k is in sorted set m is a sorted set. Unlike the in function for Set, this routine will thrown an error if k is not  convertible to eltype(m).  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.in-Tuple{Pair, SortedDict}","page":"Sorted Containers","title":"Base.in","text":"Base.in(p::Pair, sd::SortedDict)\n\nReturn true if p is in sd.  Here, p is a key=>value pair.  Time: O(c log n + d) where d stands for the time to compare two values.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.in-Tuple{Pair, SortedMultiDict}","page":"Sorted Containers","title":"Base.in","text":"Base.in(p::Pair, smd::SortedMultiDict)\n\nReturn true if p is in smd. Here, p is a key=>value pair. In the The time is is O(c log n + dl) where d is the time to compare two values and  l stands for the number of entries that have the key of the given pair. (So therefore this call is inefficient if the same key addresses a large number of values, and an alternative should be considered.)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.in-Tuple{Any, Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"Base.in","text":"Base.in(x, iter::SortedContainerIterable)\n\nReturns true if x is in iter, where iter refers to any of the iterable objects described under Base.iterate(iter::SortedContainerIterable), and x is of the appropriate type. For all of the iterables except the five listed below, the algorithm used is a linear-time search. For example, the call:\n\n(k=>v) in exclusive(sd, st1, st2)\n\nwhere sd is a SortedDict, st1 and st2 are semitokens, k is a key, and v is a value, will loop over all entries in the dictionary between the two tokens and a compare for equality using isequal between the indexed item and k=>v.\n\nThe five exceptions are:\n\n(k=>v) in sd\n(k=>v) in smd\nk in ss\nk in keys(sd)\nk in keys(smd)\n\nHere, sd is a SortedDict, smd is a SortedMultiDict, and ss is a SortedSet.\n\nThese five invocations of in use the index structure of the sorted container and test equality based on the order object of the keys rather than isequal. Therefore, these five are all faster than linear-time looping. To force the use of isequal test on the keys rather than the order object (thus slowing the execution from logarithmic to linear time), replace the above five constructs with these:\n\n(k=>v) in collect(sd)\n(k=>v) in collect(smd)\nk in collect(ss)\nk in collect(keys(sd))\nk in collect(keys(smd))\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Misc.-Functions","page":"Sorted Containers","title":"Misc. Functions","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Base.isempty(m::SortedContainer)\nBase.empty!(m::SortedContainer)\nBase.empty(m::SortedContainer)\nBase.length(m::SortedContainer)\nBase.eltype(m::SortedContainer)\nBase.keytype(m::SortedContainer)\nBase.valtype(m::SortedContainer)\nBase.eltype(m::SortedContainerIteration)\nBase.keytype(m::SortedContainerIteration)\nBase.valtype(m::SortedContainerIteration)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"These functions from Base are all applicable to sorted containers with the obvious meaning.  The eltype, keytype, and valtype functions may be applied either to the object m or its type. Note that keytype and valtype are applicable only to SortedDict and SortedMultiDict, or to pairs iterations over SortedDict or SortedMultiDict. Time: O(1)","category":"page"},{"location":"sorted_containers/#DataStructures.ordtype-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.ordtype","text":"ordtype(sc::SortedSet)\nordtype(sc::SortedDict)\nordtype(sc::SortedMultiDict)\n\nReturn the order type for a sorted container. This function may also be applied to the type itself. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.orderobject-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}","page":"Sorted Containers","title":"DataStructures.orderobject","text":"orderobject(sc::SortedContainer)\n\nReturn the order object used to construct the container. Time: O(1)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.haskey-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}","page":"Sorted Containers","title":"Base.haskey","text":"haskey(sc::SortedContainer, k)\n\nReturn true iff key k is present in sc.  Equivalent to  in(k,sc) for a SortedSet, or to in(k,keys(sc)) for a SortedDict or SortedMultiDict.  Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.get-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.get","text":"Base.get(sd::SortedDict,k,default)\nBase.get(default_f::Union{Function,Type}, sd::SortedDict, k)\n\nReturn the value associated with key k where sd is a SortedDict, or else returns default if k is not in sd.   The second form obtains default as the return argument of the function/type-constructor default_f (with no arguments)  when the key is not present. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.get!-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.get!","text":"Base.get!(sd::SortedDict,k,default)\nBase.get!(default_f::Union{Function,Type}, sd::SortedDict, k)\n\nReturn the value associated with key k where sd is a SortedDict, or else return default if k is not in sd, and in the latter case, inserts (k,default) into sd.  The second form computes a default value by calling the function default_f (with no arguments) or the constructor of type default_f when the key is not present. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.getkey-Tuple{SortedDict, Any, Any}","page":"Sorted Containers","title":"Base.getkey","text":"Base.getkey(sd::SortedDict,k,defaultk)\n\nReturn the key k where sd is a SortedDict, if k is in sd else it returns defaultk. If the container uses in its ordering an eq method different from isequal (e.g., case-insensitive ASCII strings illustrated below), then the return value is the actual key stored in the SortedDict that is equivalent to k according to the eq method, which might not be equal to k. Similarly, if the user performs an implicit conversion as part of the call (e.g., the container has keys that are floats, but the k argument to getkey is an Int), then the returned key is the actual stored key rather than k. Time: O(c log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.isequal-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.isequal","text":"Base.isequal(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K,Ord <: Ordering}\nBase.issetequal(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K,Ord <: Ordering}\n\nCheck if two sorted sets are equal in the sense that they contain the same items. Note that isequal in this sense does not imply correspondence between semitokens for items in sc1 with those for sc2.  Time: O(cn) where n is the size of the smaller container.  If the two sorted sets have K, different Ord, or  different order objects, then a fallback routine isequal(::AbstractSet, ::AbstractSet) is invoked.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, SortedDict{K, V, Ord}}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.isequal","text":"Base.isequal(sd1::SortedDict{K,V,Ord}, sd2::SortedDict{K,V,Ord}) where {K, V, Ord <: Ordering}\n\nCheck if two SortedDicts are equal in the sense that they contain the same items; the keys are compared using the eq method, while the values are compared with the isequal function.   Note that isequal in this sense does not imply correspondence between semitokens for items in sd1 with those for sd2.   Time: O(cn). Note that if K, V, Ord, or the order objects of sd1 and sd2 are different, then a fallback routine Base.isequal(::AbstractDict, ::AbstractDict) is invoked. Time: O(cn)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedMultiDict{K, V, Ord}, SortedMultiDict{K, V, Ord}}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.isequal","text":"Base.isequal(smd1::SortedMultiDict{K,V,Ord}, smd2::SortedMultiDict{K,V,Ord}) where {K, V, Ord <: Ordering}\n\nCheck if two SortedMultiDicts are equal in the sense that they contain the same items in the same order (that is, the same insertion order). They must have the same order object, else they compare unequal. The keys are compared using the eq method, while the values are compared with the isequal function. Note that isequal in this sense does not imply any correspondence between semitokens for items in smd1 with those for smd2.  Time: O(cn)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.packcopy-Tuple{SortedSet}","page":"Sorted Containers","title":"DataStructures.packcopy","text":"copy(sc::SortedSet)\ncopy(sc::SortedDict)\ncopy(sc::SortedMultiDict)\npackcopy(sc::SortedSet)\npackcopy(sc::SortedDict)\npackcopy(sc::SortedMultiDict)\n\nReturn a copy of sc, where sc is a sorted container, in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(cn)\n\nNote that the semitokens valid for the original container are no longer valid for the copy because the indexing structure is rebuilt by these copies.  If an exact copy is needed in which semitokens remain valid, use Base.deepcopy.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#DataStructures.packdeepcopy-Tuple{SortedSet}","page":"Sorted Containers","title":"DataStructures.packdeepcopy","text":"packdeepcopy(sc::SortedSet)\npackdeepcopy(sc::SortedDict)\npackdeepcopy(sc::SorteMultiDict)\n\nReturn a packed copy of sc, where sc is a sorted container in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(cn)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.merge-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.merge","text":"Base.merge(sd::SortedDict{K,V,Ord}, d1::AbstractDict{K,V}...) where {K,V,Ord <: Ordering}\n\nMerge one or more dicts into a single SortedDict and return the new SortedDict.  Arguments d1 etc. must have the same key-value type as sd. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored.  Time: O(cN log N), where N is the total size of all the arguments.  If all the arguments are SortedDicts with the same key, value, and order object, then the time is O(cN).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.merge!-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.merge!","text":"Base.merge!(sd::SortedDict{K,V,Ord}, d1::AbstractDict{K,V}...) where {K,V,Ord<:Ordering}\n\nMerge one or more dicts d1, etc. into sd. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.merge-Tuple{SortedMultiDict, Vararg{Any}}","page":"Sorted Containers","title":"Base.merge","text":"Base.merge(smd::SortedMultiDict, iter...)\n\nMerge smd and one or more iterables and return the resulting new SortedMultiDict. The iterables must have the same key-value type as smd. Items with equal keys are stored with left-to-right ordering.   Time: O(cN log N), where N is the total size of all the arguments.  If all the arguments are SortedMultiDicts with the same key, value, and order object, then the time is O(cN).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.merge!-Tuple{SortedMultiDict, Vararg{Any}}","page":"Sorted Containers","title":"Base.merge!","text":"Base.merge!(smd::SortedMultiDict, iter...)\n\nMerge one or more iterables iter, etc. into smd. These must all must have the same key-value types. Items with equal keys are stored with left-to-right ordering.  Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Set-operations","page":"Sorted Containers","title":"Set operations","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The SortedSet container supports the following set operations. Note that in the case of intersect, symdiff and setdiff, the two SortedSets should have the same key and ordering object. If they have different key or ordering types, no error message is produced; instead, the built-in default versions of these functions (that can be applied to Any iterables and that return arrays) are invoked.","category":"page"},{"location":"sorted_containers/#Base.union!-Tuple{SortedSet, Vararg{Any}}","page":"Sorted Containers","title":"Base.union!","text":"Base.union!(ss::SortedSet, iterable...)\n\nInsert each item among the second and following arguments  (which must be iterable) into the SortedSet ss. The items must be convertible to the key-type of ss. Time: O(cN log N) where N is the total number of items in the iterable arguments.  \n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.union-Tuple{SortedSet, Vararg{Any}}","page":"Sorted Containers","title":"Base.union","text":"Base.union(ss::SortedSet, iterable...)\n\nCompute and return the union of a sorted set and one or more iterables.  They must have the same keytype.  If they are all sorted sets with the same order object, then the required time is O(cn), where n is the total size.  If not, then the fallback routine requires time O(cn log n).\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.intersect-Tuple{SortedSet, Vararg{Any}}","page":"Sorted Containers","title":"Base.intersect","text":"Base.intersect(ss::SortedSet, others...)\n\nIntersect SortedSets with other SortedSets or other iterables and return the intersection as a new SortedSet. Time: O(cn), where n is the total number of items in all the arguments if all the arguments are SortedSets of the same type and same order object.  Otherwise, the time is O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.symdiff-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.symdiff","text":"Base.symdiff(ss1::SortedSet, iterable)\n\nCompute and return the symmetric difference of ss1 and iterable, i.e., a sorted set containing entries that are in one of ss1 or iterable but not both. Time: O(cn), where n is the total size of the two containers if both are sorted sets with the same key and order objects. Otherwise, the time is O(cn log n)\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.setdiff-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord<:Base.Order.Ordering}","page":"Sorted Containers","title":"Base.setdiff","text":"Base.setdiff(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K, Ord<:Ordering}\nBase.setdiff(ss1::SortedSet, others...)\n\nReturn the set difference, i.e., a sorted set containing entries in ss1 but not in ss2 or successive arguments.   Time for the first form: O(cn) where n is the total size of both sets provided that they are both sorted sets of the same type and order object.   The second form computes the set difference between ss1 and all the others, which are all iterables.  The second form requires O(cn log n) time.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.setdiff!-Tuple{SortedSet, Any}","page":"Sorted Containers","title":"Base.setdiff!","text":"Base.setdiff!(ss::SortedSet, iterable..)\n\nDelete items in ss that appear in any of the iterables. The arguments after the first  must be iterables each of whose entries must  convertible to the key type of m1.  Time: O(cm log n), where n is the size of ss and m is the  total number of items in iterable.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Base.issubset-Tuple{Any, SortedSet}","page":"Sorted Containers","title":"Base.issubset","text":"Base.issubset(iterable, ss::SortedSet)\n\nCheck whether each item of the first argument is an element of  ss. The entries must be convertible to the key-type of ss. Time: O(cm log n), where n is the size of ss and m is the number of items in iterable.  If both are sorted sets of the same keytype and order object and if m > n / log n, then an algorithm whose running time is O(c(m+n)) is used.\n\n\n\n\n\n","category":"method"},{"location":"sorted_containers/#Ordering-of-keys","page":"Sorted Containers","title":"Ordering of keys","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As mentioned earlier, the default ordering of keys uses isless and isequal functions. If the default ordering is used, it is a requirement of the container that isequal(a,b) is true if and only if !isless(a,b) and !isless(b,a) are both true. This relationship between isequal and isless holds for common built-in types, but it may not hold for all types, especially user-defined types. If it does not hold for a certain type, then a custom ordering argument must be defined as discussed in the next few paragraphs.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The name for the default ordering (i.e., using isless and isequal) is Forward. Note: this is the name of the ordering object; its type is ForwardOrdering. Another possible ordering object is Reverse, which reverses the usual sorted order. This name must be imported import Base.Reverse if it is used.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As an example of a custom ordering, suppose the keys are of type String, and the user wishes to order the keys ignoring case: APPLE, berry and Cherry would appear in that order, and APPLE and aPPlE would be indistinguishable in this ordering.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The simplest approach is to define an ordering object of the form Lt(my_isless), where Lt is a built-in type (see ordering.jl) and my_isless is the user's comparison function. In the above example, the ordering object would be:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Lt((x,y) -> isless(lowercase(x),lowercase(y)))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The ordering object is indicated in the above list of constructors in the o position (see above for constructor syntax).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"This approach may suffer from a performance hit because higher performance may be possible if an equality method is also available as well as a less-than method. A more complicated but higher-performance method to implement a custom ordering is as follows. First, the user creates a singleton type that is a subtype of Ordering as follows:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"struct CaseInsensitive <: Ordering\nend","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Next, the user defines a method named lt for less-than in this ordering:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"lt(::CaseInsensitive, a, b) = isless(lowercase(a), lowercase(b))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The first argument to lt is an object of the CaseInsensitive type (there is only one such object since it is a singleton type). The container also needs an equal-to function; the default is:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"eq(o::Ordering, a, b) = !lt(o, a, b) && !lt(o, b, a)","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The user can also customize this function with a more efficient implementation. In the above example, an appropriate customization would be:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"eq(::CaseInsensitive, a, b) = isequal(lowercase(a), lowercase(b))","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Note: the user-defined eq and lt functions must be compatible in the sense that !lt(o, a, b) && !lt(o, b, a) if and only if  eq(o, a, b).","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"Finally, the user specifies the unique element of CaseInsensitive, namely the object CaseInsensitive(), as the ordering object to the SortedDict, SortedMultiDict or SortedSet constructor.","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"For the above code to work, the module must make the following declarations, typically near the beginning:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"import Base.Ordering\nimport Base.lt\nimport DataStructures.eq","category":"page"},{"location":"sorted_containers/#Cautionary-note-on-mutable-keys","page":"Sorted Containers","title":"Cautionary note on mutable keys","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"As with ordinary Dicts, keys for the sorted containers can be either mutable or immutable. In the case of mutable keys, it is important that the keys not be mutated once they are in the container else the indexing structure will be corrupted. (The same restriction applies to Dict.) For example, the following sequence of statements leaves sd in a corrupted state:","category":"page"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"sd = SortedDict{Vector{Int},Int}()\nk = [1,2,3]\nsd[k] = 19\nsd[[6,4]] = 12\nk[1] = 7","category":"page"},{"location":"sorted_containers/#Performance-of-Sorted-Containers","page":"Sorted Containers","title":"Performance of Sorted Containers","text":"","category":"section"},{"location":"sorted_containers/","page":"Sorted Containers","title":"Sorted Containers","text":"The sorted containers are currently not optimized for cache performance.","category":"page"},{"location":"heaps/#Heaps","page":"Heaps","title":"Heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps are data structures that efficiently maintain the minimum (or maximum) for a set of data that may dynamically change.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"All heaps in this package are derived from AbstractHeap, and provide the following interface:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let `h` be a heap, `v` be a value, and `n` be an integer size\n\nlength(h)            # returns the number of elements\n\nisempty(h)           # returns whether the heap is empty\n\nempty!(h)            # reset the heap\n\npush!(h, v)          # add a value to the heap\n\nfirst(h)             # return the first (top) value of a heap\n\npop!(h)              # removes the first (top) value, and returns it\n\nextract_all!(h)      # removes all elements and returns sorted array\n\nextract_all_rev!(h)  # removes all elements and returns reverse sorted array\n\nsizehint!(h, n)      # reserve capacity for at least `n` elements","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Mutable heaps (values can be changed after being pushed to a heap) are derived from AbstractMutableHeap <: AbstractHeap, and additionally provides the following interface:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let `h` be a heap, `i` be a handle, and `v` be a value.\n\ni = push!(h, v)            # adds a value to the heap and and returns a handle to v\n\nupdate!(h, i, v)           # updates the value of an element (referred to by the handle i)\n\ndelete!(h, i)              # deletes the node with handle i from the heap\n\nv, i = top_with_handle(h)  # returns the top value of a heap and its handle","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Currently, both min/max versions of binary heap (type BinaryHeap) and mutable binary heap (type MutableBinaryHeap) have been implemented.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Examples of constructing a heap:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryMinHeap{Int}()\nh = BinaryMaxHeap{Int}()             # create an empty min/max binary heap of integers\n\nh = BinaryMinHeap([1,4,3,2])\nh = BinaryMaxHeap([1,4,3,2])         # create a min/max heap from a vector\n\nh = MutableBinaryMinHeap{Int}()\nh = MutableBinaryMaxHeap{Int}()      # create an empty mutable min/max heap\n\nh = MutableBinaryMinHeap([1,4,3,2])\nh = MutableBinaryMaxHeap([1,4,3,2])  # create a mutable min/max heap from a vector","category":"page"},{"location":"heaps/#Using-alternate-orderings","page":"Heaps","title":"Using alternate orderings","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps can also use alternate orderings apart from the default one defined by Base.isless. This is accomplished by passing an instance of Base.Ordering as the first argument to the constructor. The top of the heap will then be the element that comes first according to this ordering.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The following example uses 2-tuples to track the index of each element in the original array, but sorts only by the data value:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"data = collect(enumerate([\"foo\", \"bar\", \"baz\"]))\n\nh1 = BinaryHeap(data) # Standard lexicographic ordering for tuples\nfirst(h1)             # => (1, \"foo\")\n\nh2 = BinaryHeap(Base.By(last), data) # Order by 2nd element only\nfirst(h2)                            # => (2, \"bar\")","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"If the ordering type is a singleton it can be passed as a type parameter to the constructor instead:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"BinaryHeap{T, O}()        # => BinaryHeap{T}(O())\nMutableBinaryHeap{T, O}() # => MutableBinaryHeap{T}(O())","category":"page"},{"location":"heaps/#Min-max-heaps","page":"Heaps","title":"Min-max heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Min-max heaps maintain the minimum and the maximum of a set, allowing both to be retrieved in constant (O(1)) time. The min-max heaps in this package are subtypes of AbstractMinMaxHeap <: AbstractHeap and have the same interface as other heaps with the following additions:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"# Let h be a min-max heap, k an integer\nminimum(h)     # return the smallest element\nmaximum(h)     # return the largest element\n\npopmin!(h)     # remove and return the smallest element\npopmin!(h, k)  # remove and return the smallest k elements\n\npopmax!(h)     # remove and return the largest element\npopmax!(h, k)  # remove and return the largest k elements\n\npopall!(h)     # remove and return all the elements, sorted smallest to largest\npopall!(h, o)  # remove and return all the elements according to ordering o","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The usual first(h) and pop!(h) are defined to be minimum(h) and popmin!(h), respectively.","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"This package includes an implementation of a binary min-max heap (BinaryMinMaxHeap).","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Atkinson, M.D., Sack, J., Santoro, N., & Strothotte, T. (1986). Min-Max > Heaps and Generalized Priority Queues. Commun. ACM, 29, 996-1000. doi: 10.1145/6617.6621","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Examples:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryMinMaxHeap{Int}()        # create an empty min-max heap with integer values\n\nh = BinaryMinMaxHeap([1, 2, 3, 4]) # create a min-max heap from a vector","category":"page"},{"location":"heaps/#Functions-using-heaps","page":"Heaps","title":"Functions using heaps","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Heaps can be used to extract the largest or smallest elements of an array without sorting the entire array first:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"data = [0,21,-12,68,-25,14]\nnlargest(3, data)  # => [68,21,14]\nnsmallest(3, data) # => [-25,-12,0]","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"Both methods also support the by and lt keywords to customize the sort order, as in Base.sort:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"nlargest(3, data, by=x -> x^2)  # => [68,-25,21]\nnsmallest(3, data, by=x -> x^2) # => [0,-12,14]","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"The lower-level DataStructures.nextreme function takes a Base.Ordering instance as the first argument and returns the first n elements according to this ordering:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"DataStructures.nextreme(Base.Forward, n, a) # Equivalent to nsmallest(n, a)","category":"page"},{"location":"heaps/#Improving-performance-with-Float-data","page":"Heaps","title":"Improving performance with Float data","text":"","category":"section"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"One use case for custom orderings is to achieve faster performance with Float elements with the risk of random ordering if any elements are NaN. The provided DataStructures.FasterForward and DataStructures.FasterReverse orderings are optimized for this purpose and may achieve a 2x performance boost:","category":"page"},{"location":"heaps/","page":"Heaps","title":"Heaps","text":"h = BinaryHeap{Float64, DataStructures.FasterForward}() # faster min heap\nh = BinaryHeap{Float64, DataStructures.FasterReverse}() # faster max heap\n\nh = MutableBinaryHeap{Float64, DataStructures.FasterForward}() # faster mutable min heap\nh = MutableBinaryHeap{Float64, DataStructures.FasterReverse}() # faster mutable max heap\n\nDataStructures.nextreme(DataStructures.FasterReverse(), n, a)  # faster nlargest(n, a)\nDataStructures.nextreme(DataStructures.FasterForward(), n, a)  # faster nsmallest(n, a)","category":"page"},{"location":"robin_dict/#RobinDict","page":"RobinDict","title":"RobinDict","text":"","category":"section"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"RobinDict provides a standard dictionary, conforming to the AbstractDict protocol, which uses the Robin Hood hashing algorithm with backward-shift deletion to provide improved average performance over Dict.","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"The interface of RobinDict replicates that of Dict. This has an ordered version called OrderedRobinDict, which replicates the interface of OrderedDict.","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"Examples:","category":"page"},{"location":"robin_dict/","page":"RobinDict","title":"RobinDict","text":"julia> d = RobinDict{Int, Char}(1 => 'a', 2 => 'b')\nRobinDict{Int64, Char} with 2 entries:\n  2 => 'b'\n  1 => 'a'\n\njulia> d[3] = 'c';\n\njulia> collect(d)\n3-element Vector{Pair{Int64, Char}}:\n 2 => 'b'\n 3 => 'c'\n 1 => 'a'\n\njulia> delete!(d, 2);\n\njulia> d[1]\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> d\nRobinDict{Int64, Char} with 2 entries:\n  3 => 'c'\n  1 => 'a'\n\njulia> pop!(d)\n3 => 'c'","category":"page"},{"location":"splay_tree/#Splay-Tree","page":"Splay Tree","title":"Splay Tree","text":"","category":"section"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"The SplayTree type is an implementation of Splay Tree in Julia. It is a self-balancing binary search tree with the additional property that recently accessed elements are quick to access again. Operations such as search, insert and delete can be done in O(log n) amortized time, where n is the number of nodes in the SplayTree.","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"Examples:","category":"page"},{"location":"splay_tree/","page":"Splay Tree","title":"Splay Tree","text":"julia> tree = SplayTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> haskey(tree, 3)\ntrue\n\njulia> tree[4]\n7\n\njulia> for k in 1:2:10\n           delete!(tree, k)\n       end\n\njulia> haskey(tree, 5)\nfalse","category":"page"},{"location":"dibit_vector/#DiBitVector","page":"DiBitVector","title":"DiBitVector","text":"","category":"section"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"DiBitVector provides a memory-efficient vector of elements that represent four different values from 0 to 3. This structure is comparable to a BitVector in its performance and memory characteristics.","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"Examples:","category":"page"},{"location":"dibit_vector/","page":"DiBitVector","title":"DiBitVector","text":"julia> v = DiBitVector(4, 0)\n4-element DiBitVector:\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> w = DiBitVector(4, 2)\n4-element DiBitVector:\n 0x02\n 0x02\n 0x02\n 0x02\n\njulia> v[1] = 2\n2\n\njulia> v[2:4] .= 2\n3-element view(::DiBitVector, 2:4) with eltype UInt8:\n 0x02\n 0x02\n 0x02\n\njulia> v == w\ntrue\n\njulia> pop!(v)\n0x02\n\njulia> length(v)\n3","category":"page"},{"location":"accumulators/#Accumulators-and-Counters","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"A accumulator, as defined below, is a data structure that maintains an accumulated number for each key. This is a counter when the accumulated values reflect the counts:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"struct Accumulator{K, V<:Number}\n    map::Dict{K, V}\nend","category":"page"},{"location":"accumulators/#Constructors","page":"Accumulators and Counters","title":"Constructors","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"There are different ways to construct an accumulator/counter:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"a = Accumulator{K, V}()  # construct an accumulator with key-type K and\n                         # accumulated value type V\n\na = Accumulator(dict)    # construct an accumulator from a dictionary\n\na = counter(K)           # construct a counter, i.e. an accumulator with\n                         # key type K and value type Int\n\na = counter(dict)        # construct a counter from a dictionary\n\na = counter(seq)         # construct a counter by counting keys in a sequence\n\na = counter(gen)         # construct a counter by counting keys in a generator","category":"page"},{"location":"accumulators/#Usage","page":"Accumulators and Counters","title":"Usage","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"Usage of an accumulator/counter:","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"# let a and a2 be accumulators/counters\n\na[x]             # get the current value/count for x,\n                 # if x was not added to a, it returns zero.\n\na[x] = v         # sets the current value/count for `x` to `v`\n\ninc!(a, x)       # increment the value/count for x by 1\ninc!(a, x, v)    # increment the value/count for x by v\n\ndec!(a, x)       # decrement the value/count for x by 1\ndec!(a, x, v)    # decrement the value/count for x by v\n\nreset!(a, x)     # remove a key x from a, and return its current value\n\nmerge!(a, a2)    # add all counts from a2 to a1\nmerge(a, a2)     # return a new accumulator/counter that combines the\n                 # values/counts in both a and a2\n                 # `a[v] + a2[v]` over all `v` in the universe","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"merge is the multiset sum operation (sometimes written ⊎).","category":"page"},{"location":"accumulators/#Use-as-a-multiset","page":"Accumulators and Counters","title":"Use as a multiset","text":"","category":"section"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"An Accumulator{T, <:Integer} where T such as is returned by counter, is a multiset or Bag, of objects of type T. If the count type is not an integer but a more general real number, then this is a form of fuzzy multiset. We support a number of operations supporting the use of Accumulators as multisets.","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"Note that these operations will throw an error if the accumulator has negative or zero counts for any items.","category":"page"},{"location":"accumulators/","page":"Accumulators and Counters","title":"Accumulators and Counters","text":"\nsetdiff(a1, a2)          # The opposite of `merge` (i.e. multiset sum),\n                         # returns a new multiset with the count of items in `a2` removed from `a1`, down to a minimum of zero\n                         # `max(a1[v] - a2[v], 0)` over all `v` in the universe\n\n\nunion(a1, a2)            # multiset union (sometimes called maximum, or lowest common multiple)\n                         # returns a new multiset with the counts being the higher of those in `a1` or `a2`.\n                         # `max(a1[v], a2[v])` over all `v` in the universe\n\nintersect(a1, a2)        # multiset intersection (sometimes called infimum or greatest common divisor)\n                         # returns a new multiset with the counts being the lowest of those in `a1` or `a2`.\n                         # Note that this means things not occurring in both with be removed (count zero).\n                         # `min(a1[v], a2[v])` over all `v` in the universe","category":"page"},{"location":"linked_list/#Linked-List","page":"Linked List","title":"Linked List","text":"","category":"section"},{"location":"linked_list/","page":"Linked List","title":"Linked List","text":"A list of sequentially linked nodes. This allows efficient insertion of nodes to the front of the list:","category":"page"},{"location":"linked_list/","page":"Linked List","title":"Linked List","text":"julia> l1 = nil()\nnil()\n\njulia> l2 = cons(1, l1)\nlist(1)\n\njulia> l3 = list(2, 3)\nlist(2, 3)\n\njulia> l4 = cat(l1, l2, l3)\nlist(1, 2, 3)\n\njulia> l5 = map((x) -> x*2, l4)\nlist(2, 4, 6)\n\njulia> for i in l5; print(i); end\n246","category":"page"},{"location":"priority-queue/#Priority-Queue","page":"Priority Queue","title":"Priority Queue","text":"","category":"section"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"The PriorityQueue type provides a basic priority queue implementation allowing for arbitrary key and priority types. Multiple identical keys are not permitted, but the priority of existing keys can be changed efficiently.","category":"page"},{"location":"priority-queue/#Constructors","page":"Priority Queue","title":"Constructors","text":"","category":"section"},{"location":"priority-queue/#DataStructures.PriorityQueue","page":"Priority Queue","title":"DataStructures.PriorityQueue","text":"PriorityQueue{K, V}([ord])\n\nConstruct a new PriorityQueue, with keys of type K and values/priorities of type V. If an order is not given, the priority queue is min-ordered using the default comparison for V.\n\nA PriorityQueue acts like a Dict, mapping values to their priorities. New elements are added using push! and retrieved using popfirst! or popat! based on their priority.\n\nParameters\n\nK::Type Data type for the keys\n\nV::Type Data type for the values/priorities\n\nord::Base.Ordering Priority queue ordering\n\nExamples\n\njulia> PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n\n\n\n\n\n","category":"type"},{"location":"priority-queue/#Usage","page":"Priority Queue","title":"Usage","text":"","category":"section"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"The PriorityQueue type implements the following methods:","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"delete!(pd::PriorityQueue, key)\nempty!(pd::PriorityQueue)\nfirst(pd::PriorityQueue)\nhaskey(pd::PriorityQueue, key)\nisempty(pd::PriorityQueue)\nlength(pd::PriorityQueue)\npopfirst!(pd::PriorityQueue)\npush!(pd::PriorityQueue)","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"note: Note\nPriorityQueue also behaves similarly to a Dict in that keys can be inserted and priorities accessed or changed using indexing notation.Examples:julia> pq = PriorityQueue();\n\njulia> # Insert keys with associated priorities\n       pq[\"a\"] = 10; pq[\"b\"] = 5; pq[\"c\"] = 15; pq\nPriorityQueue{Any, Any, Base.Order.ForwardOrdering} with 3 entries:\n  \"b\" => 5\n  \"a\" => 10\n  \"c\" => 15\n\njulia> # Change the priority of an existing key\n       pq[\"a\"] = 0; pq\nPriorityQueue{Any, Any, Base.Order.ForwardOrdering} with 3 entries:\n  \"a\" => 0\n  \"b\" => 5\n  \"c\" => 15It is also possible to iterate over the priorities and elements of the queue in sorted order.julia> pq = PriorityQueue(\"a\" => 2, \"b\" => 1, \"c\" => 3)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"b\" => 1\n  \"a\" => 2\n  \"c\" => 3\n\njulia> for priority in values(pq)\n           println(priority)\n       end\n1\n2\n3\n\njulia> for element in keys(pq)\n           println(element)\n       end\nb\na\nc\n\njulia> for (element, priority) in pq\n           println(\"$element $priority\")\n       end\nb 1\na 2\nc 3","category":"page"},{"location":"priority-queue/","page":"Priority Queue","title":"Priority Queue","text":"","category":"page"},{"location":"priority-queue/#Base.delete!-Tuple{PriorityQueue, Any}","page":"Priority Queue","title":"Base.delete!","text":"delete!(pq::PriorityQueue, key)\n\nDelete the mapping for the given key in a priority queue pq and return the priority queue.\n\nExamples\n\njulia> q = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\njulia> delete!(q, \"b\")\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"c\" => 1\n  \"a\" => 2\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.empty!-Tuple{PriorityQueue}","page":"Priority Queue","title":"Base.empty!","text":"empty!(pq::PriorityQueue)\n\nReset priority queue pq.\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.first-Tuple{PriorityQueue}","page":"Priority Queue","title":"Base.first","text":"first(pq::PriorityQueue)\n\nReturn the lowest priority pair (k, v) from pq without removing it from the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.haskey-Tuple{PriorityQueue, Any}","page":"Priority Queue","title":"Base.haskey","text":"haskey(pq::PriorityQueue, key)\n\nVerify if priority queue pq has key in its keys.\n\nExample\n\njulia> pq = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n\njulia> haskey(pq, \"a\")\ntrue\n\njulia> haskey(pq, \"e\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.isempty-Tuple{PriorityQueue}","page":"Priority Queue","title":"Base.isempty","text":"isempty(pq::PriorityQueue)\n\nVerify if priority queue pq is empty.\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.length-Tuple{PriorityQueue}","page":"Priority Queue","title":"Base.length","text":"length(pq::PriorityQueue)\n\nReturn the number of pairs (k, v) in the priority queue pq.\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.popfirst!-Tuple{PriorityQueue}","page":"Priority Queue","title":"Base.popfirst!","text":"popfirst!(pq::PriorityQueue)\n\nRemove and return the lowest priority key and value from a priority queue pq as a pair.\n\nExamples\n\njulia> a = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n\njulia> popfirst!(a)\n\"c\" => 1\n\njulia> a\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"a\" => 2\n  \"b\" => 3\n\n\n\n\n\n","category":"method"},{"location":"priority-queue/#Base.push!-Union{Tuple{V}, Tuple{K}, Tuple{PriorityQueue{K, V}, Pair{K, V}}} where {K, V}","page":"Priority Queue","title":"Base.push!","text":"push!(pq::PriorityQueue{K,V}, pair::Pair{K,V}) where {K,V}\n\nInsert the a key k into a priority queue pq with priority v.\n\nExamples\n\njulia> a = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3, \"e\" => 5)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 4 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"e\" => 5\n\njulia> push!(a, \"d\" => 4)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 5 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"d\" => 4\n  \"e\" => 5\n\n\n\n\n\n","category":"method"},{"location":"ordered_containers/#OrderedDicts-and-OrderedSets","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"","category":"section"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"OrderedDicts are simply dictionaries whose entries have a particular order. For OrderedDicts (and OrderedSets), order refers to insertion order, which allows deterministic iteration over the dictionary or set:","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"d = OrderedDict{Char,Int}()\nfor c in 'a':'e'\n    d[c] = c-'a'+1\nend\ncollect(d) # => [('a',1),('b',2),('c',3),('d',4),('e',5)]\n\ns = OrderedSet(π,e,γ,catalan,φ)\ncollect(s) # => [π = 3.1415926535897...,\n           #     e = 2.7182818284590...,\n           #     γ = 0.5772156649015...,\n           #     catalan = 0.9159655941772...,\n           #     φ = 1.6180339887498...]","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"All standard Dict functions are available for OrderedDicts, and all Set operations are available for OrderedSets.","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"Note that to create an OrderedSet of a particular type, you must specify the type in curly-braces:","category":"page"},{"location":"ordered_containers/","page":"OrderedDicts and OrderedSets","title":"OrderedDicts and OrderedSets","text":"# create an OrderedSet of Strings\nstrs = OrderedSet{AbstractString}()","category":"page"},{"location":"circ_buffer/#CircularBuffer","page":"CircularBuffer","title":"CircularBuffer","text":"","category":"section"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"The CircularBuffer type implements a circular buffer of fixed capacity where new items are pushed to the back of the list, overwriting values in a circular fashion.","category":"page"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"Usage:","category":"page"},{"location":"circ_buffer/","page":"CircularBuffer","title":"CircularBuffer","text":"cb = CircularBuffer{Int}(n)   # allocate an Int buffer with maximum capacity n\nisfull(cb)           # test whether the buffer is full\nisempty(cb)          # test whether the buffer is empty\nempty!(cb)           # reset the buffer\ncapacity(cb)         # return capacity\nlength(cb)           # get the number of elements currently in the buffer\nsize(cb)             # same as length(cb)\npush!(cb, 10)        # add an element to the back and overwrite front if full\npop!(cb)             # remove the element at the back\npushfirst!(cb, 10)   # add an element to the front and overwrite back if full\npopfirst!(cb)        # remove the element at the front\nappend!(cb, [1, 2, 3, 4])     # push at most last `capacity` items\nconvert(Vector{Float64}, cb)  # convert items to type Float64\neltype(cb)           # return type of items\ncb[1]                # get the element at the front\ncb[end]              # get the element at the back\nfill!(cb, data)      # grows the buffer up-to capacity, and fills it entirely, preserving existing elements.","category":"page"},{"location":"red_black_tree/#Red-Black-Tree","page":"Red Black Tree","title":"Red Black Tree","text":"","category":"section"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"The RBTree type is an implementation of Red Black Tree in Julia. It is a self-balancing binary search tree with an extra bit of information, the color, in each of its node. Operations such as search, insert and delete can be done in O(log n) complexity, where n is the number of nodes in the RBTree.","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"Examples:","category":"page"},{"location":"red_black_tree/","page":"Red Black Tree","title":"Red Black Tree","text":"julia> tree = RBTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> haskey(tree, 3)\ntrue\n\njulia> tree[4]\n7\n\njulia> for k in 1:2:10\n           delete!(tree, k)\n       end\n\njulia> haskey(tree, 5)\nfalse","category":"page"},{"location":"swiss_dict/#SwissDict","page":"SwissDict","title":"SwissDict","text":"","category":"section"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"SwissDict provides a standard dictionary, conforming to the AbstractDict protocol, which is inspired from SwissTable developed by Google. This provides improved performance over Dict at extremely high Load Factor.","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"The interface of SwissDict replicates that of Dict.","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"Examples:","category":"page"},{"location":"swiss_dict/","page":"SwissDict","title":"SwissDict","text":"julia> d = SwissDict(1 => 'a', 2 => 'b')\nSwissDict{Int64, Char} with 2 entries:\n  1 => 'a'\n  2 => 'b'\n\njulia> d[3] = 'c';\n\njulia> collect(d)\n3-element Vector{Pair{Int64, Char}}:\n 1 => 'a'\n 2 => 'b'\n 3 => 'c'\n\njulia> delete!(d, 2);\n\njulia> d[1]\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> d\nSwissDict{Int64, Char} with 2 entries:\n  1 => 'a'\n  3 => 'c'\n\njulia> pop!(d)\n1 => 'a'","category":"page"},{"location":"mutable_linked_list/#Mutable-Linked-List","page":"Mutable Linked List","title":"Mutable Linked List","text":"","category":"section"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"The MutableLinkedList type implements a doubly linked list with mutable nodes. This data structure supports constant-time insertion/removal of elements at both ends of the list.","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"Usage:","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"l = MutableLinkedList{T}()        # initialize an empty list of type T\nl = MutableLinkedList{T}(elts...) # initialize a list with elements of type T\nisempty(l)                        # test whether list is empty\nlength(l)                         # get the number of elements in list\ncollect(l)                        # return a vector consisting of list elements\neltype(l)                         # return type of list\nfirst(l)                          # return value of first element of list\nlast(l)                           # return value of last element of list\nl1 == l2                          # test lists for equality\nmap(f, l)                         # return list with f applied to elements\nfilter(f, l)                      # return list of elements where f(el) == true\nreverse(l)                        # return reversed list\ncopy(l)                           # return a copy of list\ngetindex(l, idx)   || l[idx]      # get value at index\ngetindex(l, range) || l[range]    # get values within range a:b\nsetindex!(l, data, idx)           # set value at index to data\nappend!(l1, l2)                   # attach l2 at the end of l1\nappend!(l, elts...)               # attach elements at end of list\ndelete!(l, idx)                   # delete element at index\ndelete!(l, range)                 # delete elements within range a:b\npush!(l, data)                    # add element to end of list\npushfirst!(l, data)               # add element to beginning of list\npop!(l)                           # remove element from end of list\npopfirst!(l)                      # remove element from beginning of list","category":"page"},{"location":"mutable_linked_list/","page":"Mutable Linked List","title":"Mutable Linked List","text":"MutableLinkedList implements the Iterator interface, iterating over the list from first to last.","category":"page"},{"location":"stack/#Stack","page":"Stack","title":"Stack","text":"","category":"section"},{"location":"stack/","page":"Stack","title":"Stack","text":"The Stack data structure corresponds to a Last In, First Out (LIFO) queue in  which elements are added to and removed from only one of the ends of the queue. In DataStructures.jl the Stack type is a light-weight wrapper around the Deque type.","category":"page"},{"location":"stack/","page":"Stack","title":"Stack","text":"note: Notes on the Iterator interface implemented by the Stack\nThe Stack type implements the Julia Iterator interface; iterating over Stack returns items in First In, Last Out (FILO) order, i.e. \"from top to bottom\" of the stack. There is also a Iterators.reverse function which iterates over the items in First In, First Out (FIFO) order, or \"from bottom to top\" of the stack.julia> s = Stack{Int64}()\nStack{Int64}(Deque [Int64[]])\n\njulia> for i in 1:4\n           push!(s, i)\n       end\n\njulia> for el in s # top to bottom iteration \n           println(el)\n       end\n4\n3\n2\n1\n\njulia> for el in Iterators.reverse(s) # bottom to top iteration \n           println(el)\n       end\n1\n2\n3\n4","category":"page"},{"location":"stack/#Constructors","page":"Stack","title":"Constructors","text":"","category":"section"},{"location":"stack/#DataStructures.Stack","page":"Stack","title":"DataStructures.Stack","text":"Stack{T}() where {T}\nStack{T}(blksize::Integer) where {T}\n\nCreate a Stack object containing elements of type T for Last In, First Out (LIFO) access.\n\nParameters\n\nT::Type Stack element data type.\nblksize::Integer Unrolled linked-list block size (in bytes) used in the   underlying representation of the stack. Default = 1024. \n\nExamples\n\njulia> s_int = Stack{Int64}() # create a stack with Int64 elements\nStack{Int64}(Deque [Int64[]])\n\njulia> s_float = Stack{Float64}() # create a stack with Float64 elements\nStack{Float64}(Deque [Float64[]])\n\n\n\n\n\n","category":"type"},{"location":"stack/#Usage","page":"Stack","title":"Usage","text":"","category":"section"},{"location":"stack/","page":"Stack","title":"Stack","text":"The Stack type implements the following methods:","category":"page"},{"location":"stack/","page":"Stack","title":"Stack","text":"==(x::Stack, y::Stack)\neltype(::Type{Stack{T}}) where {T}\nempty!(s::Stack)\nfirst(s::Stack)\nisempty(s::Stack)\nlength(s::Stack)\npop!(s::Stack)\npush!(s::Stack, x)","category":"page"},{"location":"stack/","page":"Stack","title":"Stack","text":"","category":"page"},{"location":"stack/#Base.:==-Tuple{Stack, Stack}","page":"Stack","title":"Base.:==","text":"==(x::Stack, y::Stack)\n\nCheck if stacks x and y are equal in terms of their contents and the order in which they are present in the stack. Internally calls ==() for each of the pairs formed by the elements of x and y in the order they appear in the stack.\n\nExample\n\njulia> s1, s2 = Stack{String}(), Stack{String}()\n(Stack{String}(Deque [String[]]), Stack{String}(Deque [String[]]))\n\njulia> for string in [\"foo\", \"bar\", \"42\"]\n          push!(s1, string)\n          push!(s2, string)\n       end\n\njulia> s1 == s2\ntrue\n\njulia> pop!(s1)\n\"42\"\n\njulia> s1 == s2\nfalse\n\njulia> a, b = Stack{Int}(), Stack{Int}()\n(Stack{Int64}(Deque [Int64[]]), Stack{Int64}(Deque [Int64[]]))\n\njulia> for num in [1, 2, 3, 4] push!(a, num) end\n\njulia> for num in [1, 2, 4, 3] push!(b, num) end\n\njulia> a == b # same elements but in different order\nfalse\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.eltype-Union{Tuple{Type{Stack{T}}}, Tuple{T}} where T","page":"Stack","title":"Base.eltype","text":"eltype(::Type{Stack{T}}) where {T}\n\nReturn the type of the elements in the stack.\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.empty!-Tuple{Stack}","page":"Stack","title":"Base.empty!","text":"empty!(s::Stack)\n\nMake s empty by inplace-removing all its elements.\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.first-Tuple{Stack}","page":"Stack","title":"Base.first","text":"first(s::Stack)\n\nGet the first element of s in Last In, First Out order. Since s is a stack, the first element will be the element at the top of s (also known as \"peek\" of the stack).\n\nExample\n\njulia> s = Stack{Float32}()\nStack{Float32}(Deque [Float32[]])\n\njulia> for i in range(1, 0.2, 5)\n           push!(s, i)\n       end\n\njulia> s\nStack{Float32}(Deque [Float32[1.0, 0.8, 0.6, 0.4, 0.2]])\n\njulia> first(s)\n0.2f0\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.isempty-Tuple{Stack}","page":"Stack","title":"Base.isempty","text":"isempty(s::Stack)\n\nReturns true if stack s is empty - i.e. has no elements - or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.last-Tuple{Stack}","page":"Stack","title":"Base.last","text":"last(s::Stack)\n\nGet the last element of s in Last In, First Out. Since s is a stack, the last element will be the at bottom of the stack.\n\nExample\n\njulia> s = Stack{Float32}()\nStack{Float32}(Deque [Float32[]])\n\njulia> for i in range(1, 0.2, 5)\n           push!(s, i)\n       end\n\njulia> s\nStack{Float32}(Deque [Float32[1.0, 0.8, 0.6, 0.4, 0.2]])\n\njulia> last(s)\n1.0f0\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.length-Tuple{Stack}","page":"Stack","title":"Base.length","text":"length(s::Stack)\n\nReturn the number of elements in stack s.\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.pop!-Tuple{Stack}","page":"Stack","title":"Base.pop!","text":"pop!(s::Stack)\n\nRemove and return the top element from stack s.\n\n\n\n\n\n","category":"method"},{"location":"stack/#Base.push!-Tuple{Stack, Any}","page":"Stack","title":"Base.push!","text":"push!(s::Stack, x)\n\nInsert new element x in top of stack s.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#AVL-Tree","page":"AVL Tree","title":"AVL Tree","text":"","category":"section"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"The AVL Tree is a self-balancing binary search tree in which balancing operations take place based on the difference of height between the left and right subtrees. Such operations may occur during the insertion and deletion of keys performing recursive rotate operations to ensue that the difference between the heights of the left and right substrees is restricted to -1 1.","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"(Image: )","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"Example of AVL Tree with balance factors shown in green.","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"AVL Trees are often compared with Red–Black Trees because both take O(log n) time for the basic operations. However, for lookup-intensive applications, AVL Trees are faster than Red–Black Trees because they are more strictly balanced. Similar to Red–Black Trees, AVL Trees are height-balanced.","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"note: Complexity\nComputational complexity for common operations using an AVL TreeOperation Average Case Worst Case\nSpace Theta(n) O(n)\nSearch Theta(log n) O(log n)\nInsertion Theta(log n) O(log n)\nDeletion Theta(log n) O(log n)","category":"page"},{"location":"avl_tree/#Constructors","page":"AVL Tree","title":"Constructors","text":"","category":"section"},{"location":"avl_tree/#DataStructures.AVLTree","page":"AVL Tree","title":"DataStructures.AVLTree","text":"AVLTree{T}\n\nConstruct new AVLTree with keys of type T.\n\nExample\n\njulia> tree = AVLTree{Int64}()\nAVLTree{Int64}(nothing, 0)\n\n\n\n\n\n","category":"type"},{"location":"avl_tree/#Usage","page":"AVL Tree","title":"Usage","text":"","category":"section"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"The AVLTree type implements the following methods:","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"delete!(tree::AVLTree{K}, k::K) where K\nin(key, tree::AVLTree)\ngetindex(tree::AVLTree{K}, ind::Integer) where K\nhaskey(tree::AVLTree{K}, k::K) where K\npush!(tree::AVLTree{K}, k) where K\nsorted_rank(tree::AVLTree{K}, key::K) where K","category":"page"},{"location":"avl_tree/","page":"AVL Tree","title":"AVL Tree","text":"","category":"page"},{"location":"avl_tree/#Base.delete!-Union{Tuple{K}, Tuple{AVLTree{K}, K}} where K","page":"AVL Tree","title":"Base.delete!","text":"delete!(tree::AVLTree{K}, k::K) where K\n\nDelete key k from tree AVL tree.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#Base.getindex-Union{Tuple{K}, Tuple{AVLTree{K}, Integer}} where K","page":"AVL Tree","title":"Base.getindex","text":"getindex(tree::AVLTree{K}, ind::Integer) where K\n\nConsidering the elements of tree sorted, returns the ind-th element in tree. Search operation is performed in O(log n) time complexity.\n\nExamples\n\njulia> tree = AVLTree{Int}()\nAVLTree{Int64}(nothing, 0)\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> tree[4]\n7\n\njulia> tree[8]\n15\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#Base.haskey-Union{Tuple{K}, Tuple{AVLTree{K}, K}} where K","page":"AVL Tree","title":"Base.haskey","text":"haskey(tree::AVLTree{K}, k::K) where K\n\nVerify if AVL tree tree contains the key k. Analogous to in(key, tree::AVLTree).\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#Base.in-Tuple{Any, AVLTree}","page":"AVL Tree","title":"Base.in","text":"in(key, tree::AVLTree)\n\nIn infix  operator for key and tree types. Analogous to haskey(tree::AVLTree{K}, k::K) where K.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#Base.length-Tuple{AVLTree}","page":"AVL Tree","title":"Base.length","text":"length(tree::AVLTree)\n\nReturn number of elements in AVL tree tree.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#Base.push!-Union{Tuple{K}, Tuple{AVLTree{K}, Any}} where K","page":"AVL Tree","title":"Base.push!","text":"push!(tree::AVLTree{K}, key) where K\n\nInsert key in AVL tree tree.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#DataStructures.left_rotate-Tuple{DataStructures.AVLTreeNode}","page":"AVL Tree","title":"DataStructures.left_rotate","text":"left_rotate(node_x::AVLTreeNode)\n\nPerforms a left-rotation on node_x, updates height of the nodes, and returns the rotated node.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#DataStructures.minimum_node-Tuple{Union{Nothing, DataStructures.AVLTreeNode}}","page":"AVL Tree","title":"DataStructures.minimum_node","text":"minimum_node(tree::AVLTree, node::AVLTreeNode)\n\nReturns the AVLTreeNode with minimum value in subtree of node.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#DataStructures.right_rotate-Tuple{DataStructures.AVLTreeNode}","page":"AVL Tree","title":"DataStructures.right_rotate","text":"right_rotate(node_x::AVLTreeNode)\n\nPerforms a right-rotation on node_x, updates height of the nodes, and returns the rotated node.\n\n\n\n\n\n","category":"method"},{"location":"avl_tree/#DataStructures.sorted_rank-Union{Tuple{K}, Tuple{AVLTree{K}, K}} where K","page":"AVL Tree","title":"DataStructures.sorted_rank","text":"sorted_rank(tree::AVLTree{K}, key::K) where K\n\nReturns the rank of key present in the tree, if it present. A KeyError is thrown if key is not present.\n\nExamples\n\njulia> tree = AVLTree{Int}();\n\njulia> for k in 1:2:20\n           push!(tree, k)\n       end\n\njulia> sorted_rank(tree, 17)\n9\n\n\n\n\n\n","category":"method"},{"location":"queue/#Queue","page":"Queue","title":"Queue","text":"","category":"section"},{"location":"queue/","page":"Queue","title":"Queue","text":"The Queue data structure, also known as First In, First Out (FIFO) queue, allows addition and deletion of items in opposite ends of the data structure. Insertion is performed in the back of the queue while deletion is performed in the front of the queue. In DataStructures.jl, the Queue type is a light-weight wrapper around the Deque type.","category":"page"},{"location":"queue/","page":"Queue","title":"Queue","text":"Queues are often used as a base for many different data structures, some of its variations implemented by DataStructures.jl include:","category":"page"},{"location":"queue/","page":"Queue","title":"Queue","text":"Double Ended Queues\nCircular Double Ended Queues\nPriority Queues","category":"page"},{"location":"queue/#Constructors","page":"Queue","title":"Constructors","text":"","category":"section"},{"location":"queue/#DataStructures.Queue","page":"Queue","title":"DataStructures.Queue","text":"Queue{T}() where {T}\nQueue{T}([blksize::Integer=1024])\n\nCreate a Queue object containing elements of type T for First In, First Out (FIFO) access.\n\nParameters\n\nT::Type Queue element data type.\nblksize::Integer=1024 Unrolled linked-list block size (in bytes). Default = 1024.\n\nExamples\n\njulia> q_int = Queue{Int64}() # create a queue with int elements\nQueue{Int64}(Deque [Int64[]])\n\njulia> q_float = Queue{Float64}() # create a queue with float elements\nQueue{Float64}(Deque [Float64[]])\n\n\n\n\n\n","category":"type"},{"location":"queue/#Usage","page":"Queue","title":"Usage","text":"","category":"section"},{"location":"queue/","page":"Queue","title":"Queue","text":"The Queue type implements the following methods:","category":"page"},{"location":"queue/","page":"Queue","title":"Queue","text":"eltype(::Type{Queue{T}}) where {T}\nfirst(q::Queue)\nisempty(q::Queue)\nlength(q::Queue)\nlast(q::Queue)\npush!(q::Queue, x)\npopfirst!(q::Queue)","category":"page"},{"location":"queue/","page":"Queue","title":"Queue","text":"","category":"page"},{"location":"queue/#Base.:==-Tuple{Queue, Queue}","page":"Queue","title":"Base.:==","text":"==(x::Queue, y::Queue)\n\nVerify if queues x and y are equivalent in their contents.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.eltype-Union{Tuple{Type{Queue{T}}}, Tuple{T}} where T","page":"Queue","title":"Base.eltype","text":"eltype(::Type{Queue{T}}) where {T}\n\nReturn the type of the elements in the queue.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.empty!-Tuple{Queue}","page":"Queue","title":"Base.empty!","text":"empty!(q::Queue)\n\nRemoves all elements from queue q.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.first-Tuple{Queue}","page":"Queue","title":"Base.first","text":"first(q::Queue)\n\nGet the first item from queue q.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.isempty-Tuple{Queue}","page":"Queue","title":"Base.isempty","text":"isempty(q::Queue)\n\nCheck if queue q is empty.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.last-Tuple{Queue}","page":"Queue","title":"Base.last","text":"last(q::Queue)\n\nGet the last element in queue q.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.length-Tuple{Queue}","page":"Queue","title":"Base.length","text":"length(q::Queue)\n\nReturn the number of elements in queue q.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.popfirst!-Tuple{Queue}","page":"Queue","title":"Base.popfirst!","text":"popfirst!(q::Queue)\n\nRemoves an element from the front of the queue q and returns it.\n\n\n\n\n\n","category":"method"},{"location":"queue/#Base.push!-Tuple{Queue, Any}","page":"Queue","title":"Base.push!","text":"push!(q::Queue, x)\n\nInserts the value x to the end of the queue q.\n\n\n\n\n\n","category":"method"},{"location":"trie/#Trie","page":"Trie","title":"Trie","text":"","category":"section"},{"location":"trie/","page":"Trie","title":"Trie","text":"An implementation of the Trie data structure. This is an associative structure, with iterable keys:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"julia> t = Trie{Char,Int}();\n\n\njulia> t[\"Rob\"] = 42;\n\n\njulia> t[\"Roger\"] = 24;\n\n\njulia> haskey(t, \"Rob\")\ntrue\n\njulia> get(t, \"Rob\", nothing)\n42\n\njulia> keys(t)\n2-element Vector{String}:\n \"Roger\"\n \"Rob\"\n\njulia> keys(subtrie(t, \"Ro\"))\n2-element Vector{String}:\n \"ger\"\n \"b\"","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"Note that the keys don't need to be Strings:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"julia> t = Trie{Int,Char}();\n\njulia> t[1:3] = 'a';\n\njulia> t[[2,3,5]] = 'b';\n\njulia> keys(t)\n2-element Vector{Vector{Int64}}:\n [2, 3, 5]\n [1, 2, 3]","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"Constructors:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"Trie(keys, values)                  # construct a Trie with the given keys and values\nTrie(keys)                          # construct a Trie{K,Nothing} with the given keys and with values = nothing\nTrie(kvs::AbstractVector{(K, V)})   # construct a Trie from the given vector of (key, value) pairs\nTrie(kvs::AbstractDict{K, V})       # construct a Trie from the given associative structure","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"This package also provides an iterator partial_path(t::Trie, prefix) for looping over all the nodes encountered in searching for the given prefix. This obviates much of the boilerplate code needed in writing many trie algorithms. For example, to test whether a trie contains any prefix of a given string str, use:","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"seen_prefix(t::Trie, str) = any(v -> v.is_key, partial_path(t, str))","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"find_prefixes can be used to find all keys which are prefixes of the given string.","category":"page"},{"location":"trie/","page":"Trie","title":"Trie","text":"julia> t = Trie([\"A\", \"ABC\", \"ABCD\", \"BCE\"]);\n\njulia> find_prefixes(t, \"ABCDE\")\n3-element Vector{String}:\n \"A\"\n \"ABC\"\n \"ABCD\"","category":"page"},{"location":"#DataStructures.jl","page":"DataStructures.jl","title":"DataStructures.jl","text":"","category":"section"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"This package implements a variety of data structures, including","category":"page"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"Deque (implemented with an unrolled linked list)\nCircularBuffer\nCircularDeque (based on a circular buffer)\nStack\nQueue\nPriority Queue\nFenwick Tree\nAccumulators and Counters (i.e. Multisets / Bags)\nDisjoint Sets\nBinary Heap\nMutable Binary Heap\nOrdered Dicts and Sets\nRobinDict and OrderedRobinDict (implemented with Robin Hood Hashing)\nSwissDict (inspired from SwissTables)\nDictionaries with Defaults\nTrie\nLinked List and Mutable Linked List\nSorted Dict, Sorted Multi-Dict and Sorted Set\nDataStructures.IntSet\nSparseIntSet\nDiBitVector\nRed Black Tree\nAVL Tree\nSplay Tree","category":"page"},{"location":"#Contents","page":"DataStructures.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"DataStructures.jl","title":"DataStructures.jl","text":"Pages = [\n    \"index.md\",\n    \"deque.md\",\n    \"circ_buffer.md\",\n    \"circ_deque.md\",\n    \"stack_and_queue.md\",\n    \"priority-queue.md\",\n    \"fenwick.md\",\n    \"accumulators.md\",\n    \"disjoint_sets.md\",\n    \"heaps.md\",\n    \"ordered_containers.md\",\n    \"default_dict.md\",\n    \"robin_dict.md\",\n    \"trie.md\",\n    \"linked_list.md\",\n    \"mutable_linked_list.md\",\n    \"intset.md\",\n    \"sorted_containers.md\",\n    \"sparse_int_set.md\",\n    \"dibit_vector.md\",\n    \"red_black_tree.md\",\n    \"avl_tree.md\",\n    \"splay_tree.md\",\n]","category":"page"},{"location":"intset/#DataStructures.IntSet","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"","category":"section"},{"location":"intset/","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"DataStructures.IntSet is a drop-in replacement for the Base BitSet type. It efficiently stores dense collections of small non-negative Ints as a sorted set. The constructor IntSet([itr]) constructs a sorted set of the integers generated by the given iterable object, or an empty set if no argument is given. If the set will be sparse (for example holding a few very large integers), use Set or SortedSet instead.","category":"page"},{"location":"intset/","page":"DataStructures.IntSet","title":"DataStructures.IntSet","text":"A complement IntSet may be constructed with complement or complement!. The complement of an empty IntSet contains typemax(Int) elements from 0 to typemax(Int)-1.","category":"page"},{"location":"fenwick/#Fenwick-Tree","page":"Fenwick Tree","title":"Fenwick Tree","text":"","category":"section"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"The FenwickTree type is data structures which is used for handling increment and decrement to prefix-sums of an array efficiently.","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"Usage:","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"FenwickTree{T}(n) # Constructs a Fenwick Tree of length `n`\nFenwickTree{T}(counts)  # Constructs a Fenwick Tree from an array of `counts`\ninc!(ft, ind, val)  # Increases the value of the FenwickTree `ft` by `val` from the index `ind` upto the length of `ft`\ndec!(ft, ind, val)  # Decreases the value of the FenwickTree `ft` by `val` from the index `ind` upto the length of `ft`\nincdec!(ft, left, right, val)  # Increases the value of the FenwickTree `ft` by `val` from the indices from `left` and decreases it from the `right`\nprefixsum(ft, ind)  # Return the cumulative sum from index 1 upto `ind` of the FenwickTree `ft`","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"Examples:","category":"page"},{"location":"fenwick/","page":"Fenwick Tree","title":"Fenwick Tree","text":"julia> f = FenwickTree{Int}(6)\njulia> inc!(f, 2, 5)\njulia> prefixsum(f, 1)\n 0\njulia> prefixsum(f, 3)\n 5","category":"page"}]
}
