<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sorted Containers · DataStructures.jl</title><meta name="title" content="Sorted Containers · DataStructures.jl"/><meta property="og:title" content="Sorted Containers · DataStructures.jl"/><meta property="twitter:title" content="Sorted Containers · DataStructures.jl"/><meta name="description" content="Documentation for DataStructures.jl."/><meta property="og:description" content="Documentation for DataStructures.jl."/><meta property="twitter:description" content="Documentation for DataStructures.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataStructures.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DataStructures.jl</a></li><li><a class="tocitem" href="../deque/">Deque</a></li><li><a class="tocitem" href="../circ_buffer/">CircularBuffer</a></li><li><a class="tocitem" href="../circ_deque/">CircularDeque</a></li><li><a class="tocitem" href="../stack/">Stack</a></li><li><a class="tocitem" href="../queue/">Queue</a></li><li><a class="tocitem" href="../priority-queue/">Priority Queue</a></li><li><a class="tocitem" href="../fenwick/">Fenwick Tree</a></li><li><a class="tocitem" href="../accumulators/">Accumulators and Counters</a></li><li><a class="tocitem" href="../disjoint_sets/">Disjoint-Sets</a></li><li><a class="tocitem" href="../heaps/">Heaps</a></li><li><a class="tocitem" href="../ordered_containers/">OrderedDicts and OrderedSets</a></li><li><a class="tocitem" href="../default_dict/">DefaultDict and DefaultOrderedDict</a></li><li><a class="tocitem" href="../robin_dict/">RobinDict</a></li><li><a class="tocitem" href="../swiss_dict/">SwissDict</a></li><li><a class="tocitem" href="../trie/">Trie</a></li><li><a class="tocitem" href="../linked_list/">Linked List</a></li><li><a class="tocitem" href="../mutable_linked_list/">Mutable Linked List</a></li><li><a class="tocitem" href="../intset/">DataStructures.IntSet</a></li><li class="is-active"><a class="tocitem" href>Sorted Containers</a><ul class="internal"><li><a class="tocitem" href="#Tokens-for-Sorted-Containers"><span>Tokens for Sorted Containers</span></a></li><li><a class="tocitem" href="#Complexity-of-Sorted-Containers"><span>Complexity of Sorted Containers</span></a></li><li><a class="tocitem" href="#Constructors-for-Sorted-Containers"><span>Constructors for Sorted Containers</span></a></li><li><a class="tocitem" href="#Navigating-the-Containers"><span>Navigating the Containers</span></a></li><li><a class="tocitem" href="#Inserting-and-Deleting-in-Sorted-Containers"><span>Inserting &amp; Deleting in Sorted Containers</span></a></li><li><a class="tocitem" href="#Iteration-and-Token-Manipulation"><span>Iteration and Token Manipulation</span></a></li><li><a class="tocitem" href="#Misc.-Functions"><span>Misc. Functions</span></a></li><li><a class="tocitem" href="#Set-operations"><span>Set operations</span></a></li><li><a class="tocitem" href="#Ordering-of-keys"><span>Ordering of keys</span></a></li><li><a class="tocitem" href="#Cautionary-note-on-mutable-keys"><span>Cautionary note on mutable keys</span></a></li><li><a class="tocitem" href="#Performance-of-Sorted-Containers"><span>Performance of Sorted Containers</span></a></li></ul></li><li><a class="tocitem" href="../dibit_vector/">DiBitVector</a></li><li><a class="tocitem" href="../red_black_tree/">Red Black Tree</a></li><li><a class="tocitem" href="../avl_tree/">AVL Tree</a></li><li><a class="tocitem" href="../splay_tree/">Splay Tree</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sorted Containers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sorted Containers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaCollections/DataStructures.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaCollections/DataStructures.jl/blob/master/docs/src/sorted_containers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sorted-Containers"><a class="docs-heading-anchor" href="#Sorted-Containers">Sorted Containers</a><a id="Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Sorted-Containers" title="Permalink"></a></h1><p>Three sorted containers are provided: SortedDict, SortedMultiDict and SortedSet. <em>SortedDict</em> is similar to the built-in Julia type <code>Dict</code> with the additional feature that the keys are stored in sorted order and can be efficiently iterated in this order. SortedDict is a subtype of AbstractDict. It is generally slower than <code>Dict</code> because looking up a key requires an O(log <em>n</em>) tree search rather than an expected O(1) hash-table lookup time of <code>Dict</code>. SortedDict is a parameterized type with three parameters, the key type <code>K</code>, the value type <code>V</code>, and the ordering type <code>O</code>. SortedSet has only keys; it is an alternative to the built-in <code>Set</code> container and is a subtype of AbstractSet. Internally, SortedSet is implemented as a SortedDict in which the value type is <code>Nothing</code>. Finally, SortedMultiDict is similar to SortedDict except that each key can be associated with multiple values. The key=&gt;value pairs in a SortedMultiDict are stored according to the sorted order for keys, and key=&gt;value pairs with the same key are stored in order of insertion.</p><p>The containers internally use a 2-3 tree, which is a kind of balanced tree and is described in data structure textbooks.  Internally, one <code>Vector</code> is used to store key/data pairs (the leaves of the tree) while a second holds the tree structure.</p><p>The containers require two functions to compare keys: a <em>less-than</em> and <em>equals</em> function. With the default ordering argument, the comparison functions are <code>isless(key1,key2)</code> (true when <code>key1 &lt; key2</code>) and <code>isequal(key1,key2)</code> (true when <code>key1 == key2</code>) where <code>key1</code> and <code>key2</code> are keys. More details are provided below.</p><h2 id="Tokens-for-Sorted-Containers"><a class="docs-heading-anchor" href="#Tokens-for-Sorted-Containers">Tokens for Sorted Containers</a><a id="Tokens-for-Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Tokens-for-Sorted-Containers" title="Permalink"></a></h2><p>The sorted containers support an object for indexing called a <em>token</em> defined as a two-entry tuple and aliased as <code>SortedDictToken</code>, <code>SortedMultiDictToken</code>, or <code>SortedSetToken</code>. A token is the address of a single data item in the container and can be dereferenced in time O(1).</p><p>The first entry of a token tuple is the container as a whole, and the second refers to the particular item. The second part is called a <em>semitoken</em>. The type of the semitoken is <code>IntSemiToken</code>.</p><p>A restriction for the sorted containers is that <code>IntSemiToken</code> cannot used as the key-type. This is because ambiguity would result between the two subscripting calls <code>sc[k]</code> and <code>sc[st]</code> described below. In the rare scenario that a sorted container whose key-type is <code>IntSemiToken</code> is required, a workaround is to wrap the key inside another immutable structure.</p><p>The notion of token is similar to the concept of iterators used by C++ standard containers. Tokens can be explicitly advanced or regressed through the data in the sorted order; they are implicitly advanced or regressed via iteration defined below.</p><p>A token may take two special values: the <em>before-start</em> value and the <em>past-end</em> value. These values act as lower and upper bounds on the actual data. The before-start token can be advanced, while the past-end token can be regressed. A dereferencing operation on either leads to an error.</p><p>In the current implementation, semitokens are internally stored as integers. Users should regard these integers as opaque since future versions of the package may change the internal indexing scheme. In certain situations it may be more costly to operate on tokens than semitokens because the first entry of a token (i.e., the container) is not a bits-type. If code profiling indicates that statements using tokens are allocating memory, then it may be advisable to rewrite the application code using semitokens rather than tokens.</p><h2 id="Complexity-of-Sorted-Containers"><a class="docs-heading-anchor" href="#Complexity-of-Sorted-Containers">Complexity of Sorted Containers</a><a id="Complexity-of-Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-of-Sorted-Containers" title="Permalink"></a></h2><p>In the list of functions below, the running time of the various operations is provided. In these running times, <em>n</em> denotes the number of items in the container, and <em>c</em> denotes the time needed to compare two keys.</p><h2 id="Constructors-for-Sorted-Containers"><a class="docs-heading-anchor" href="#Constructors-for-Sorted-Containers">Constructors for Sorted Containers</a><a id="Constructors-for-Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-for-Sorted-Containers" title="Permalink"></a></h2><h3 id="SortedDict-constructors"><a class="docs-heading-anchor" href="#SortedDict-constructors"><code>SortedDict</code> constructors</a><a id="SortedDict-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#SortedDict-constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedDict{K,V,Ord}(o::Ord=Forward) where {K, V, Ord &lt;: Ordering}
SortedDict{K,V,Ord}(o::Ord, kv) where {K, V, Ord &lt;: Ordering}</code></pre><p>Construct a <code>SortedDict</code> with key type <code>K</code> and value type <code>V</code> with <code>o</code> ordering from an iterable <code>kv</code>.  The iterable should generate either <code>Pair{K,V}</code> or <code>Tuple{K,V}</code>.  If omitted, then the SortedDict is initially empty.  Time: O(<em>cn</em> log <em>n</em>) where <em>n</em> is the length of the iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedDict-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedDict(o::Ord=Forward) where {Ord &lt;: Ordering}
SortedDict{K,V}(o::Ord=Forward) where {K,V,Ord&lt;:Ordering}</code></pre><p>Construct an empty <code>SortedDict</code> with key type <code>K</code> and value type <code>V</code> with <code>o</code> ordering (default to forward ordering).  If <code>K</code> and <code>V</code> are not specified as in the first form, then they are assumed to both be <code>Any</code>. Time: O(1)</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors in which the key type is inferred.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L32-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedDict(iter, o::Ord=Forward) where {Ord &lt;: Ordering}
SortedDict(o::Ordering, iter)
SortedDict{K,V}(iter, o::Ordering=Forward) where {K,V}
SortedDict{K,V}(o::Ordering, iter) where {K,V}</code></pre><p>Construct a <code>SortedDict</code> from an arbitrary iterable object of <code>key=&gt;value</code> pairs or <code>(key,value)</code> tuples with order object <code>o</code>. The key type and value type are inferred from the given iterable in the first two forms.  The first two forms copy the data three times, so it is more efficient to explicitly specify <code>K</code> and <code>V</code> as in the second two forms.  Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedDict-Tuple{Vararg{Pair}}" href="#DataStructures.SortedDict-Tuple{Vararg{Pair}}"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedDict(ps::Pair...)
SortedDict(o::Ordering, ps::Pair...)
SortedDict{K,V}(ps::Pair...)
SortedDict{K,V}(o::Ordering, ps::Pair...) where {K,V}</code></pre><p>Construct a <code>SortedDict</code> from the given key-value pairs.  The key type and value type are inferred from the given key-value pairs in the first two forms. The ordering is assumed to be <code>Forward</code> ordering in the first and third form.   The first two forms (where <code>K</code> and <code>V</code> are not specified but inferred) involves copying the data three times  and so is less efficient than the second two forms. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L92-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}" href="#DataStructures.SortedDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedDict{K,V}(::Val{true}, iterable) where {K, V}
SortedDict{K,V}(::Val{true}, iterable, ord::Ordering) where {K,V}</code></pre><p>Construct a <code>SortedDict</code> from an iterable whose eltype is Tuple{K,V} or Pair{K,V} and that is already in sorted ordered.  The first form assumes Forward ordering.  No duplicate keys allowed.   Time: O(<em>cn</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L116-L124">source</a></section></article><h3 id="SortedMultiDict-constructors"><a class="docs-heading-anchor" href="#SortedMultiDict-constructors"><code>SortedMultiDict</code> constructors</a><a id="SortedMultiDict-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#SortedMultiDict-constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}, Tuple{V}, Tuple{K}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedMultiDict{K,V,Ord}(o::Ord=Forward) where {K, V, Ord &lt;: Ordering}
SortedMultiDict{K,V,Ord}(o::Ord, iterable) where {K, V, Ord &lt;: Ordering}</code></pre><p>Construct a sorted multidict in which type parameters are explicitly listed; ordering object is explicitly specified.  Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedMultiDict-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedMultiDict(o::Ord=Forward) where {Ord &lt;: Ordering}
SortedMultiDict{K,V}(o::Ordering=Forward) where {K,V}</code></pre><p>Construct an empty <code>SortedMultiDict</code> with key type <code>K</code> and value type <code>V</code> with <code>o</code> ordering (default to <code>Forward</code> ordering).  If <code>K</code> and <code>V</code> are not specified as in the first form, then they are assumed to both be <code>Any</code>. Time: O(1).</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors in which the key type is inferred.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedMultiDict-Tuple{Vararg{Pair}}" href="#DataStructures.SortedMultiDict-Tuple{Vararg{Pair}}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedMultiDict(ps::Pair...)
SortedMultiDict(o, ps::Pair...)
SortedMultiDict{K,V}(ps::Pair...)
SortedMultiDict{K,V}(o, ps::Pair...)</code></pre><p>Construct a <code>SortedMultiDict</code> from the given key-value pairs.  The key type and value type are inferred from the given key-value pairs in the first two form. The ordering is assumed to be <code>Forward</code> ordering in the first and third forms.   The first two forms involve copying the data three times to infer the types and so are less efficient than the third and fourth form where <code>{K,V}</code> are specified explicitly.  Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{Ord}, Tuple{Any, Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedMultiDict(iter, o::Ord=Forward) where {Ord &lt;: Ordering}
SortedMultiDict(o::Ordering, iter)
SortedMultiDict{K,V}(iter, o::Ordering=Forward) where {K, V}
SortedMultiDict{K,V}(o::Ordering, iter) where {K, V}</code></pre><p>Construct a <code>SortedMultiDict</code> from an arbitrary iterable object of <code>key=&gt;value</code> pairs or (key,value) tuples with order object <code>o</code>. The key type and value type are inferred from the given iterable in the first two forms.  The first two forms copy the data three times, so it is more efficient to explicitly specify <code>K</code> and <code>V</code> as in the second two forms.  Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}" href="#DataStructures.SortedMultiDict-Union{Tuple{V}, Tuple{K}, Tuple{Val{true}, Any}} where {K, V}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedMultiDict{K,V}(::Val{true}, iterable) where {K,V}
SortedMultiDict{K,V}(::Val{true}, iterable, ord::Ord) where {K,V,Ord&lt;:Ordering}</code></pre><p>Construct a <code>SortedMultiDict</code> from an iterable whose eltype is Tuple{K,V} or Pair{K,V} and that is already in sorted ordered.  The first form assumes Forward ordering. Duplicate keys allowed. Time: O(<em>cn</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L109-L118">source</a></section></article><h3 id="SortedSet-constructors"><a class="docs-heading-anchor" href="#SortedSet-constructors"><code>SortedSet</code> constructors</a><a id="SortedSet-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#SortedSet-constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}, Tuple{K}} where {K, Ord&lt;:Base.Order.Ordering}" href="#DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}, Tuple{K}} where {K, Ord&lt;:Base.Order.Ordering}"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedSet{K,Ord}(o::Ord=Forward) where {K, Ord&lt;:Ordering}
SortedSet{K,Ord}(o::Ord, iter) where {K, Ord&lt;:Ordering}</code></pre><p>Construct a SortedSet of eltype <code>K</code>using from elements produced by  iterable <code>iter</code> (e.g., an array) and ordering object <code>o</code>.  Running time: O(<em>cn</em> log <em>n</em>) where <em>n</em> is the length of iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedSet-Union{Tuple{}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedSet(o::Ord=Forward) where {Ord &lt;: Ordering}
SortedSet{K}(o::Ord=Forward) where {K, Ord&lt;:Ordering}</code></pre><p>Construct an empty <code>SortedSet</code> with <code>Forward</code> ordering.  The first form assumes element type of <code>Any</code>.  Time: O(1).</p><p><strong>Note that an element type of <code>Any</code> or any other abstract type will lead to slow performance.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedSet-Tuple{Base.Order.Ordering, Any}" href="#DataStructures.SortedSet-Tuple{Base.Order.Ordering, Any}"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedSet(o::Ordering, iter)
SortedSet(iter, o::Ordering=Forward)
SortedSet{K}(o::Ordering, iter)
SortedSet{K}(iter, o::Ordering=Forward)</code></pre><p>Construct a sorted set from an iterable <code>iter</code> using order o.   In the first two forms, the element type is inferred from the iterable, which requires copying the data twice.  Therefore, the second two forms (specifying <code>K</code> explicitly) are more efficient. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{K}, Tuple{Val{true}, Any}} where K" href="#DataStructures.SortedSet-Union{Tuple{K}, Tuple{Val{true}, Any}} where K"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SortedSet{K}(::Val{true}, iterable) where {K}
SortedSet{K}(::Val{true}, iterable, ord::Ord) where {K, Ord &lt;: Ordering}</code></pre><p>Construct a <code>SortedSet</code> from an iterable whose entries have type <code>K</code> and that is already in sorted ordered. No duplicates allowed.  The first form assumes Forward ordering. Time: O(<em>cn</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L68-L76">source</a></section></article><h2 id="Navigating-the-Containers"><a class="docs-heading-anchor" href="#Navigating-the-Containers">Navigating the Containers</a><a id="Navigating-the-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Navigating-the-Containers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{SortedDict, Any}" href="#Base.getindex-Tuple{SortedDict, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.getindex(sd::SortedDict, k)</code></pre><p>Retrieve the value associated with key <code>k</code> in SortedDict <code>sc</code>. Yields a <code>KeyError</code> if <code>k</code> is not found.   The following functions do not throw an error if the key is not found: <a href="#Base.get-Tuple{SortedDict, Any, Any}"><code>Base.get(sd::SortedDict,k,v)</code></a> and <a href="#DataStructures.findkey-Tuple{SortedDict, Any}"><code>findkey(sd::SortedDict, k)</code></a>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L146-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{SortedDict, DataStructures.Tokens.IntSemiToken}" href="#Base.getindex-Tuple{SortedDict, DataStructures.Tokens.IntSemiToken}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.getindex(m::SortedDict, st::IntSemiToken)
Base.getindex(m::SortedMultiDict, st::IntSemiToken)</code></pre><p>Retrieve value portion of item from SortedDict or SortedMultiDict <code>m</code> indexed by <code>st</code>, a semitoken. Notation <code>m[st]</code> appearing in  an expression is equivalent to <a href="#DataStructures.deref_value-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>deref_value(token::Token)</code></a> where <code>token=(m,st)</code>.   It is a <code>BoundsError</code> if the token is invalid.  Prepending with <code>@inbounds</code> may elide the correctness check and results in undefined behavior if the token is invalid. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L352-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{SortedDict, Any, DataStructures.Tokens.IntSemiToken}" href="#Base.setindex!-Tuple{SortedDict, Any, DataStructures.Tokens.IntSemiToken}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(m::SortedDict, newvalue, st::IntSemiToken)
Base.setindex!(m::SortedMultiDict, newvalue, st::IntSemiToken)</code></pre><p>Set the value portion of item from SortedDict or SortedMultiDict <code>m</code> indexed by <code>st</code>, a semitoken to <code>newvalue</code>.   A <code>BoundsError</code> is thrown if the token is invalid. Prepending with <code>@inbounds</code> may elide the correctness check and results in undefined behavior if the token is invalid. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L381-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{SortedDict, Any, Any}" href="#Base.setindex!-Tuple{SortedDict, Any, Any}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(sd::SortedDict, newvalue, k)</code></pre><p>Assign or reassign the value associated with the key <code>k</code> to <code>newvalue</code>.  Note that the key is also overwritten; this is not necessarily a no-op since the equivalence in the sort-order does not imply equality. See also <a href="#DataStructures.push_return_semitoken!-Tuple{SortedDict, Pair}"><code>push_return_semitoken!(sd::SortedDict, p::Pair)</code></a>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.deref-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.deref-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.deref</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deref(token::Token)
deref((m,st))</code></pre><p>Return the data item indexed by the token.  If the container is a <code>SortedSet</code>, then this is a key in the set. If the container is a <code>SortedDict</code> or <code>SortedMultiDict</code>, then this is a key=&gt;value pair.  It is a <code>BoundsError</code> if the token is invalid or is the before-start or past-end token.   Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a  sorted container <code>m</code>  and a semitoken <code>st</code>.  Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L230-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.deref_key-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.deref_key-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.deref_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deref_key(token::Token)
deref_key((m,st))</code></pre><p>Return the key portion of a data item (a key=&gt;value pair) in a  <code>SortedDict</code> or <code>SortedMultiDict</code> indexed by the token. It is a <code>BoundsError</code> if the token is invalid or is the before-start or past-end token.  Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a container <code>m</code>  and a semitoken <code>st</code>.  Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L272-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.deref_value-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.deref_value-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.deref_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deref_value(token::Token)
deref_value((m,st))</code></pre><p>Returns the value portion of a data item (a key=&gt;value pair) in a <code>SortedDict</code> or <code>SortedMultiDict</code>  indexed by the token.  It is a <code>BoundsError</code> if the token is invalid or is the before-start or past-end token.  Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start or past-end token. The  second form creates the token in-place as a tuple of a container <code>m</code>  and a semitoken <code>st</code>.  Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L300-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#Base.firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>Base.firstindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.firstindex(m::SortedContainer)</code></pre><p>Return the semitoken of the first entry of the container <code>m</code>, or the past-end semitoken if the container is empty.  This function was called <code>startof</code> (now deprecated) in previous versions of the package. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#Base.lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>Base.lastindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.lastindex(m::SortedContainer)</code></pre><p>Return the semitoken of the last entry of the sorted container <code>m</code>, or the before-start semitoken if the container is empty.   This function was called <code>endof</code> (now deprecated) in previous versions of the package. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.token_firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.token_firstindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.token_firstindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">token_firstindex(m::SortedContainer)</code></pre><p>Return the token of the first entry of the sorted container <code>m</code>, or the past-end token if the container is empty.  Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.token_lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.token_lastindex-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.token_lastindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">token_lastindex(m::SortedContainer)</code></pre><p>Return the token of the last entry of the sorted container <code>m</code>, or the before-start semitoken if the container is empty.  Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.first-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#Base.first-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>Base.first</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.first(sc::SortedContainer)</code></pre><p>Return the  first item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or an element for SortedSet) in <code>sc</code> according to the sorted order in the container. It is a <code>BoundsError</code> to call this function on an empty container.  Equivalent to <code>deref(token_startindex(sc))</code>. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L328-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.last-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#Base.last-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>Base.last</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.last(sc::SortedContainer)</code></pre><p>Return the last item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) in <code>sc</code> according to the sorted order in the container. It is a <code>BoundsError</code> to call this function on an empty container. Equivalent to <code>deref(token_lastindex(sc))</code>. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L340-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.pastendsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.pastendsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.pastendsemitoken</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pastendsemitoken(m::SortedContainer)</code></pre><p>Return the semitoken of the entry that is one past the end of the sorted container <code>m</code>. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.beforestartsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.beforestartsemitoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.beforestartsemitoken</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">beforestartsemitoken(m::SortedContainer)</code></pre><p>Return the semitoken of the entry that is one before the beginning of the  sorted container <code>m</code>.  Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.pastendtoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.pastendtoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.pastendtoken</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pastendtoken(m::SortedContainer)</code></pre><p>Return the token of the entry that is one past the end of the sorted container <code>m</code>. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.beforestarttoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.beforestarttoken-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.beforestarttoken</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">beforestarttoken(m::SortedContainer)</code></pre><p>Return the token of the entry that is one before the beginning of the  sorted container <code>m</code>. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.advance-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.advance-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.advance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">advance(token::Token)
advance((m,st))</code></pre><p>Return the semitoken of the item in a sorted container one after the given token.  A <code>BoundsError</code> is thrown if the token is the past-end token.   Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid or points to the past-end token. The second form creates the token in-place as a tuple of a  container <code>m</code> and a semitoken <code>st</code>. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.regress-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.regress-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.regress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regress(token::Token)
regress((m,st))</code></pre><p>Return the semitoken of the item in a sorted container one before the given token.  A <code>BoundsError</code> is thrown if the token is the before-start token.   Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid or points to the before-start token. The second form creates the token in-place as a tuple of a container <code>m</code> and a semitoken <code>st</code>. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L150-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}, Integer}" href="#Base.:+-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}, Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.+(t::Token, j::Integer)
Base.-(t::Token, j::Integer)</code></pre><p>Return the token that is <code>j</code> positions ahead (if <code>+</code>) or behind (if <code>-</code>) of <code>t</code>. Here, <code>t</code> is a token for a sorted container and <code>j</code> is an integer.  If <code>j</code> is negative, then <code>+</code> regresses while <code>-</code> advances. If the operation <code>t+j</code> or <code>t-j</code> reaches the before-start  or past-end positions in the container, then the before-start/past-end tokens are returned (and there is no error). Time: O(<em>j</em>+log <em>n</em>), so this function is not optimized for long jumps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L1152-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Sort.searchsortedfirst-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}" href="#Base.Sort.searchsortedfirst-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}"><code>Base.Sort.searchsortedfirst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.searchsortedfirst(m::SortedContainer, k)</code></pre><p>Return the semitoken of the first item in the  sorted container <code>m</code> that is greater than or equal to <code>k</code> in the sort order. If there is no such item, then the past-end semitoken is returned.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L416-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Sort.searchsortedlast-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}" href="#Base.Sort.searchsortedlast-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}"><code>Base.Sort.searchsortedlast</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.searchsortedlast(m::SortedContainer, k)</code></pre><p>Return the semitoken of the last item in the container that is less than or equal to <code>k</code> in sort order.  If there is no such item, then the before-start semitoken is returned.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L445-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.searchsortedafter-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}" href="#DataStructures.searchsortedafter-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}"><code>DataStructures.searchsortedafter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">searchsortedafter(m::SortedContainer, k)</code></pre><p>Return the semitoken of the first item in the container that is greater than <code>k</code> in the sort order.  If there is no such item, then the past-end semitoken is returned. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L432-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.searchequalrange-Tuple{SortedMultiDict, Any}" href="#DataStructures.searchequalrange-Tuple{SortedMultiDict, Any}"><code>DataStructures.searchequalrange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStructures.searchequalrange(smd::SortedMultiDict, k)</code></pre><p>Return two semitokens that correspond to the first and last items in the SortedMultiDict that have key exactly equal to <code>k</code>.  If <code>k</code> is not found, then it returns  (pastendsemitoken(smd), beforestartsemitoken(smd)). Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.findkey-Tuple{SortedSet, Any}" href="#DataStructures.findkey-Tuple{SortedSet, Any}"><code>DataStructures.findkey</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findkey(m::SortedSet, k)</code></pre><p>Return the semitoken of the element <code>k</code> in sorted set <code>m</code>. If the element is not present in <code>m</code>, then the past-end semitoken is returned.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.findkey-Tuple{SortedDict, Any}" href="#DataStructures.findkey-Tuple{SortedDict, Any}"><code>DataStructures.findkey</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStructures.findkey(sd::SortedDict, k)</code></pre><p>Return the semitoken that  points to the item whose key is <code>k</code>, or past-end semitoken if <code>k</code> is absent.  See also  <a href="#Base.getindex-Tuple{SortedDict, Any}"><code>Base.getindex(sd::SortedDict, k)</code></a> Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L195-L203">source</a></section></article><h2 id="Inserting-and-Deleting-in-Sorted-Containers"><a class="docs-heading-anchor" href="#Inserting-and-Deleting-in-Sorted-Containers">Inserting &amp; Deleting in Sorted Containers</a><a id="Inserting-and-Deleting-in-Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Inserting-and-Deleting-in-Sorted-Containers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!-Tuple{SortedSet, Any}" href="#Base.push!-Tuple{SortedSet, Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.push!(ss::SortedSet, k)</code></pre><p>Insert the element <code>k</code> into the sorted set <code>ss</code>. If the <code>k</code> is already present, this overwrites the old value. (This is not necessarily a no-op; see remarks about the  customizing the sort order.)  See also <a href="#DataStructures.push_return_semitoken!-Tuple{SortedSet, Any}"><code>push_return_semitoken!(ss::SortedSet, k)</code></a>. The return value is <code>ss</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!-Tuple{SortedDict, Pair}" href="#Base.push!-Tuple{SortedDict, Pair}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.push!(sd::SortedDict, p::Pair)</code></pre><p>Insert key-value pair <code>p</code>, i.e., a <code>k=&gt;v</code> pair, into <code>sd</code>. If the key <code>k</code> is already present, this overwrites the old value.  The key is also overwritten (not necessarily a no-op, since  sort-order equivalence may differ from equality). The return value is <code>sd</code>.   See also <a href="#DataStructures.push_return_semitoken!-Tuple{SortedDict, Pair}"><code>push_return_semitoken!(sd::SortedDict, p::Pair)</code></a>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L179-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!-Tuple{SortedMultiDict, Pair}" href="#Base.push!-Tuple{SortedMultiDict, Pair}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.push!(smd::SortedMultiDict, p::Pair)</code></pre><p>Insert the pair <code>p</code>, i.e., a <code>k=&gt;v</code> into <code>smd</code>. If <code>k</code> already appears as a key in <code>smd</code>, then <code>k=&gt;v</code> is inserted in the rightmost position after existing items with key <code>k</code>.  Returns the container. See also <a href="#DataStructures.push_return_semitoken!-Tuple{SortedMultiDict, Pair}"><code>push_return_semitoken!(smd::SortedMultiDict, p::Pair)</code></a>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L173-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.push_return_semitoken!-Tuple{SortedSet, Any}" href="#DataStructures.push_return_semitoken!-Tuple{SortedSet, Any}"><code>DataStructures.push_return_semitoken!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStructures.push_return_semitoken!(ss::SortedSet, k)</code></pre><p>Insert the element <code>k</code> into the SortedSet <code>sc</code>. If <code>k</code> is already present, this overwrites the old value. (This is not necessarily a no-op; see remarks about the  customizing the sort order.) Unlike <code>push!</code>, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry.   This function replaces the deprecated <code>insert!</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L114-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.push_return_semitoken!-Tuple{SortedDict, Pair}" href="#DataStructures.push_return_semitoken!-Tuple{SortedDict, Pair}"><code>DataStructures.push_return_semitoken!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStructures.push_return_semitoken!(sd::SortedDict, p::Pair)</code></pre><p>Insert pair <code>p</code> of the form <code>k=&gt;v</code> into <code>sd</code>. If the key is already present in <code>sd</code>, this overwrites the old value. Note that the key is also overwritten, which is not necessarily a no-op because equivalence in the sort order does not necessarily imply equality.  Unlike <code>push!</code>, the return value is a 2-tuple whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and whose second entry is the semitoken of the new entry. This function replaces the deprecated <code>insert!(sd,k,v)</code>.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L210-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.push_return_semitoken!-Tuple{SortedMultiDict, Pair}" href="#DataStructures.push_return_semitoken!-Tuple{SortedMultiDict, Pair}"><code>DataStructures.push_return_semitoken!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataStructures.push_return_semitoken!(smd::SortedMultiDict, pr::Pair)</code></pre><p>Insert the key-value pair <code>pr</code>, i.e., <code>k=&gt;v</code>, into <code>smd</code>.   If <code>k</code> already appears as a key in <code>smd</code>, then <code>k=&gt;v</code> is inserted in the rightmost position after existing items with key <code>k</code>.  Unlike <code>push!</code>,  the return value is a 2-tuple whose first entry is boolean always equal to <code>true</code> and whose second entry is the semitoken of the new entry. (The reason for returning a bool whose value is always <code>true</code> is for consistency with <code>push_return_semitoken!</code> for SortedDict and SortedSet.) This function replaces the deprecated <code>insert!</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L151-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.delete!-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#Base.delete!-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.delete!(token::Token)</code></pre><p>Delete the item indexed by the token from a sorted container.   A <code>BoundsError</code> is thrown if the token is invalid. Prepending with <code>@inbounds</code> may elide the correctness check and will result in undefined behavior if the token is invalid. Time: O(log <em>n</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L113-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.delete!-Tuple{SortedSet, Any}" href="#Base.delete!-Tuple{SortedSet, Any}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.delete!(ss::SortedSet, k)</code></pre><p>Delete element <code>k</code> from <code>sc</code>.  After this operation is complete, a token addressing the deleted item is invalid. Returns <code>sc</code>.  if <code>k</code> is not present, this operation is a no-op. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.delete!-Tuple{SortedDict, Any}" href="#Base.delete!-Tuple{SortedDict, Any}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.delete!(sd::SortedDict, k)</code></pre><p>Delete the item whose key is <code>k</code> in <code>sd</code>. After this operation is complete, any token addressing the deleted item is invalid. Returns <code>sc</code>.  This is a no-op if <code>k</code> is not present in <code>sd</code>.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L325-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!-Tuple{SortedSet, Any}" href="#Base.pop!-Tuple{SortedSet, Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.pop!(ss::SortedSet, k)
Base.pop!(ss::SortedSet, k, default)</code></pre><p>Delete the item with key <code>k</code> in <code>ss</code> and return the item that compares equal to <code>k</code> according to the sort order (which is not necessarily <code>k</code>, since equality in the sort-order does not necessarily imply hash-equality). If <code>k</code> is not found, return <code>default</code>, or throw a <code>KeyError</code> if <code>default</code> is not specified. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!-Tuple{SortedDict, Any}" href="#Base.pop!-Tuple{SortedDict, Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.pop!(sd::SortedDict, k)
Base.pop!(sd::SortedDict, k, default)</code></pre><p>Delete the item with key <code>k</code> in <code>sd</code> and return the value that was associated with <code>k</code>. If <code>k</code> is not in <code>sd</code> return <code>default</code>, or throw a <code>KeyError</code> if <code>default</code> is not specified. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L342-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.popfirst!-Tuple{SortedSet}" href="#Base.popfirst!-Tuple{SortedSet}"><code>Base.popfirst!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.popfirst!(ss::SortedSet)</code></pre><p>Delete the item with first key in SortedSet <code>ss</code> and returns the key.  This function was named <code>pop!</code> in a previous version of the package.  A <code>BoundsError</code> results if <code>ss</code> is empty. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.poplast!-Tuple{SortedSet}" href="#DataStructures.poplast!-Tuple{SortedSet}"><code>DataStructures.poplast!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poplast!(ss::SortedSet)</code></pre><p>Delete the item with last key in SortedSet <code>ss</code> and returns the key. A <code>BoundsError</code> results if <code>ss</code> is empty.   This function will be renamed <code>Base.pop!</code> in a future version of the package. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L236-L243">source</a></section></article><h2 id="Iteration-and-Token-Manipulation"><a class="docs-heading-anchor" href="#Iteration-and-Token-Manipulation">Iteration and Token Manipulation</a><a id="Iteration-and-Token-Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-and-Token-Manipulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.compare-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken, DataStructures.Tokens.IntSemiToken}" href="#DataStructures.compare-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken, DataStructures.Tokens.IntSemiToken}"><code>DataStructures.compare</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare(m::SortedContainer, s::IntSemiToken, t::IntSemiToken)</code></pre><p>Determine the  relative position according to the sort order of the  data items indexed by tokens <code>(m,s)</code> and  <code>(m,t)</code>.  Return:</p><ul><li><code>-1</code>if<code>(m,s)</code> precedes <code>(m,t)</code>, </li><li><code>0</code> if <code>s == t</code> </li><li><code>1</code> if <code>(m,s)</code>succeeds <code>(m,t)</code>. </li></ul><p>The relative positions are determined  from the tree topology without any key comparisons. Time: O(log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L189-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.status-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}" href="#DataStructures.status-Tuple{Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, DataStructures.Tokens.IntSemiToken}}"><code>DataStructures.status</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">status(token::Token) 
status((m, st))</code></pre><p>Determine the status of a token.  Return values are:</p><ul><li>0 = invalid token</li><li>1 = valid and points to live data</li><li>2 = before-start token</li><li>3 = past-end token</li></ul><p>The second form creates the token in-place as a tuple of a sorted container <code>m</code> and a semitoken <code>st</code>. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L171-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}" href="#Base.iterate-Tuple{Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::SortedContainerIterable)</code></pre><p>with the following helper functions to construct a <code>SortedContainerIterable</code>:</p><pre><code class="nohighlight hljs">inclusive(m::SortedContainer, st1, st2)
inclusive(m::SortedContainer, (st1, st2))
inclusive_key(m::SortedContainer, key1, key2)
inclusive_key(m::SortedContainer, (key1, key2))
exclusive(m::SortedContainer, st1, st2)
exclusive(m::SortedContainer, (st1, st2))
exclusive_key(m::SortedContainer, key1, key2)
exclusive_key(m::SortedContainer, (key1, key2))
Base.keys(b)
Base.values(b)
Base.pairs(b)
Base.eachindex(b)
tokens(kv)
semitokens(kv)
onlytokens(kv)
onlysemitokens(kv)
Base.Iterators.reverse(m)
(:)(a,b)</code></pre><p>Iterate over a sorted container, typically  within a for-loop, comprehension, or generator. Here, <code>iter</code> is an iterable object constructed from a sorted container.  The possible iterable objects are constructed from the helper functions as follows:</p><p>A <em>basic</em> iterable object is either </p><ul><li>an entire sorted container <code>m</code>,</li><li><code>inclusive(m, (st1, st2))</code> or equivalently <code>inclusive(m, st1, st2)</code>, </li><li><code>inclusive_key(m, (k1, k2))</code> or equivalently <code>inclusive_key(m, k1, k2)</code></li><li><code>a:b</code>, where <code>a</code> and <code>b</code> are tokens addressing the same container</li><li><code>exclusive(m, (st1, st2))</code> or equivalently <code>exclusive(m, st1, st2)</code></li><li><code>exclusive_key(m, (k1, k2))</code> or equivalently <code>exclusive_key(m, k1, k2)</code></li></ul><p>These extract ranges of consecutive items in the containers.  In the <code>inclusive</code> and <code>exclusive</code> constructions, constructions, <code>m</code> is a container, <code>st1</code> and <code>st2</code> are semitokens.  The <code>inclusive</code> range includes both endpoints <code>st1</code> and <code>st2</code>.  The inclusive  iteration is empty if <code>compare(m,st1,st2)&lt;0</code>. The <code>exclusive</code> range includes endpoint <code>st1</code> but not <code>st2</code>.  The exclusive iteration is empty if <code>compare(m,st1,st2)&lt;=0</code>.  In the exclusive iteration, it is acceptable if <code>st2</code> is the past-end semitoken.  </p><p>The range <code>exclusive_key</code> means all data items with keys between <code>k1</code> up to but excluding items with key <code>k2</code>.  For this range to be nonempty,  <code>k1&lt;k2</code> must hold (in the sort order).   The range <code>inclusive_key</code> means all data items with keys between <code>k1</code> and <code>k2</code> inclusive.  For this range to be nonempty, <code>k1&lt;=k2</code> must hold.</p><p>A <em>kv</em> iterable object has the form </p><ul><li><code>b</code>, a basic iterable object</li><li><code>keys(b)</code> where <code>b</code> is a basic object.  Extract keys only (not applicable  to SortedSet)</li><li><code>values(b)</code> where <code>b</code> is a basic object.  Extract values only  (not applicable to SortedSet).</li><li><code>pairs(b)</code> where <code>b</code> is a basic object. Extracts key=&gt;value pairs  (not applicable to SortedSet).    This is the same as just specifying <code>b</code> and is provided only for compatibility  with <code>Base.pairs</code>.  </li></ul><p>A <em>tkv</em> object has the form </p><ul><li><code>kv</code>, a kv iterable object</li><li><code>tokens(kv)</code> where <code>kv</code> is a kv iterable object.    Return 2-tuples of the form <code>(t,w)</code>, where <code>t</code> is the  token of the item and <code>w</code> is a key or value if <code>kv</code> is a keys or values  iteration, or <code>(t,k,v)</code> if <code>kv</code> is a pairs iteration. </li><li><code>semitokens(kv)</code> where <code>kv</code> is a kv iterable object.    Return pairs of the form <code>(st,w)</code>, where <code>st</code> is the  token of the item and <code>w</code> is a key or value if <code>kv</code> is a keys or values  iteration, or <code>(st,k,v)</code> if <code>kv</code> is a pairs iteration.</li><li><code>onlytokens(kv)</code> where <code>kv</code> is a kv iterable object. Return only tokens  of the data items but not the items themselves.    The <code>keys</code>, <code>values</code>, or <code>pairs</code> modifiers described above  are ignored.</li><li><code>onlysemitokens(kv)</code> where <code>kv</code> is a kv iterable object. Return only semitokens  of the data items but not the items themselves.    The <code>keys</code>, <code>values</code>, or <code>pairs</code> modifiers described above  are ignored.</li></ul><p>Finally, a tkv iteration can be reversed by the <code>Iterators.reverse</code> function.  The <code>Iterators.reverse</code> function may be nested in an arbitrary position with respect to the other operations described  above. Two reverse operations cancel each other out.  For example, <code>Iterators.reverse(keys(Iterators.reverse(m)))</code> is the same iteration as <code>keys(m)</code>.</p><p>For compatibility with <code>Base</code>, there is also an <code>eachindex</code> function: <code>eachindex(b)</code> where the base object <code>b</code> a SortedDict is the same as <code>keys(b)</code> (to be compatible with Dict).   On the other hand, <code>eachindex(b)</code> where the base object <code>b</code> is a SortedSet or SortedMultiDict is the same as <code>onlysemitokens(b)</code>.</p><p>Colon notation <code>a:b</code>  is equivalent to <code>onlytokens(inclusive(a[1], a[2], b[2]))</code>, in other words, it yields an iteration that provides all the tokens of items in the sort order ranging from token <code>a</code> up to token <code>b</code>. It is required that <code>a[1]===b[1]</code> (i.e., <code>a</code> and <code>b</code> are tokens for the same container).  Exclusive iteration using colon notation is obtained via <code>a : b-1</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">   for (k,v) in sd
       &lt;body&gt;
   end</code></pre><p>Here, <code>sd</code> is a <code>SortedDict</code> or <code>SortedMultiDict</code>.  The variables <code>(k,v)</code>  are set to consecutive key-value pairs.  All items in the container are produced in order.</p><pre><code class="language-julia hljs">   for k in inclusive(ss, st1, st2)
       &lt;body&gt;
   end</code></pre><p>Here, <code>ss</code> is a <code>SortedSet</code>, and <code>st1</code>, and <code>st2</code> are semitokens indexing <code>ss</code>. The elements of the set between <code>st1</code> and <code>st2</code> inclusive are returned.</p><pre><code class="language-julia hljs">   for (t,k) in tokens(keys(exclusive_key(sd, key1, key2)))
      &lt;body&gt;
   end</code></pre><p>Here, <code>sd</code> is a <code>SortedDict</code> or <code>SortedMultiDict</code>, <code>key1</code> and <code>key2</code> are keys indexing <code>sd</code>.  In this case, <code>t</code> will be tokens of consecutive items, while <code>k</code> will be the corresponding keys.  The returned keys lie between <code>key1</code> and <code>key2</code> excluding <code>key2</code>.</p><pre><code class="language-julia hljs">   for (t,k) in Iterators.reverse(tokens(keys(exclusive_key(sd, key1, key2))))
      &lt;body&gt;
   end</code></pre><p>Same as above, except the iteration is in the reverse order.</p><p>Writing on the objects returned by <code>values</code> is not currently supported, e.g., the following <code>map!</code> statement is not implemented even though the  analogous statement is available for <code>Dict</code> in Base.</p><pre><code class="language-julia hljs">    s = SortedDict(3=&gt;4)
    map!(x -&gt; x*2, values(s))</code></pre><p>The workaround is an explicit loop:</p><pre><code class="language-julia hljs">    s = SortedDict(3=&gt;4)
    for t in onlysemitokens(s)
        s[t] *= 2
    end</code></pre><p>Running time for all iterations: O(<em>c</em>(<em>s</em> + log <em>n</em>)), where <em>s</em> is the number of steps from start to end of the iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L852-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Any, SortedSet}" href="#Base.in-Tuple{Any, SortedSet}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.in(k,m::SortedSet)</code></pre><p>Return <code>true</code> iff element <code>k</code> is in sorted set <code>m</code> is a sorted set. Unlike the <code>in</code> function for <code>Set</code>, this routine will thrown an error if <code>k</code> is not  convertible to <code>eltype(m)</code>.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Pair, SortedDict}" href="#Base.in-Tuple{Pair, SortedDict}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.in(p::Pair, sd::SortedDict)</code></pre><p>Return true if <code>p</code> is in <code>sd</code>.  Here, <code>p</code> is a key=&gt;value pair.  Time: O(<em>c</em> log <em>n</em> + <em>d</em>) where <em>d</em> stands for the time to compare two values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L237-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Pair, SortedMultiDict}" href="#Base.in-Tuple{Pair, SortedMultiDict}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.in(p::Pair, smd::SortedMultiDict)</code></pre><p>Return true if <code>p</code> is in <code>smd</code>. Here, <code>p</code> is a key=&gt;value pair. In the The time is is O(<em>c</em> log <em>n</em> + <em>dl</em>) where <em>d</em> is the time to compare two values and  <em>l</em> stands for the number of entries that have the key of the given pair. (So therefore this call is inefficient if the same key addresses a large number of values, and an alternative should be considered.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L238-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{Any, Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}" href="#Base.in-Tuple{Any, Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.in(x, iter::SortedContainerIterable)</code></pre><p>Returns true if <code>x</code> is in <code>iter</code>, where <code>iter</code> refers to any of the iterable objects described under <a href="#Base.iterate-Tuple{Union{DataStructures.IterableObject, SortedDict, SortedMultiDict, SortedSet}}"><code>Base.iterate(iter::SortedContainerIterable)</code></a>, and <code>x</code> is of the appropriate type. For all of the iterables except the five listed below, the algorithm used is a linear-time search. For example, the call:</p><pre><code class="nohighlight hljs">(k=&gt;v) in exclusive(sd, st1, st2)</code></pre><p>where <code>sd</code> is a SortedDict, <code>st1</code> and <code>st2</code> are semitokens, <code>k</code> is a key, and <code>v</code> is a value, will loop over all entries in the dictionary between the two tokens and a compare for equality using <code>isequal</code> between the indexed item and <code>k=&gt;v</code>.</p><p>The five exceptions are:</p><pre><code class="language-julia hljs">(k=&gt;v) in sd
(k=&gt;v) in smd
k in ss
k in keys(sd)
k in keys(smd)</code></pre><p>Here, <code>sd</code> is a SortedDict, <code>smd</code> is a SortedMultiDict, and <code>ss</code> is a SortedSet.</p><p>These five invocations of <code>in</code> use the index structure of the sorted container and test equality based on the order object of the keys rather than <code>isequal</code>. Therefore, these five are all faster than linear-time looping. To force the use of <code>isequal</code> test on the keys rather than the order object (thus slowing the execution from logarithmic to linear time), replace the above five constructs with these:</p><pre><code class="language-julia hljs">(k=&gt;v) in collect(sd)
(k=&gt;v) in collect(smd)
k in collect(ss)
k in collect(keys(sd))
k in collect(keys(smd))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L1052-L1096">source</a></section></article><h2 id="Misc.-Functions"><a class="docs-heading-anchor" href="#Misc.-Functions">Misc. Functions</a><a id="Misc.-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Misc.-Functions" title="Permalink"></a></h2><pre><code class="nohighlight hljs">Base.isempty(m::SortedContainer)
Base.empty!(m::SortedContainer)
Base.empty(m::SortedContainer)
Base.length(m::SortedContainer)
Base.eltype(m::SortedContainer)
Base.keytype(m::SortedContainer)
Base.valtype(m::SortedContainer)
Base.eltype(m::SortedContainerIteration)
Base.keytype(m::SortedContainerIteration)
Base.valtype(m::SortedContainerIteration)</code></pre><p>These functions from <code>Base</code> are all applicable to sorted containers with the obvious meaning.  The <code>eltype</code>, <code>keytype</code>, and <code>valtype</code> functions may be applied either to the object <code>m</code> or its type. Note that <code>keytype</code> and <code>valtype</code> are applicable only to SortedDict and SortedMultiDict, or to pairs iterations over SortedDict or SortedMultiDict. Time: O(1)</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.ordtype-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.ordtype-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.ordtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ordtype(sc::SortedSet)
ordtype(sc::SortedDict)
ordtype(sc::SortedMultiDict)</code></pre><p>Return the order type for a sorted container. This function may also be applied to the type itself. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L206-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.orderobject-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}" href="#DataStructures.orderobject-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}}"><code>DataStructures.orderobject</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orderobject(sc::SortedContainer)</code></pre><p>Return the order object used to construct the container. Time: O(1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.haskey-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}" href="#Base.haskey-Tuple{Union{SortedDict, SortedMultiDict, SortedSet}, Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haskey(sc::SortedContainer, k)</code></pre><p>Return <code>true</code> iff key <code>k</code> is present in <code>sc</code>.  Equivalent to  <code>in(k,sc)</code> for a SortedSet, or to <code>in(k,keys(sc))</code> for a SortedDict or SortedMultiDict.  Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_container_iteration.jl#L1104-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.get-Tuple{SortedDict, Any, Any}" href="#Base.get-Tuple{SortedDict, Any, Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.get(sd::SortedDict,k,default)
Base.get(default_f::Union{Function,Type}, sd::SortedDict, k)</code></pre><p>Return the value associated with key <code>k</code> where <code>sd</code> is a SortedDict, or else returns <code>default</code> if <code>k</code> is not in <code>sd</code>.   The second form obtains <code>default</code> as the return argument of the function/type-constructor <code>default_f</code> (with no arguments)  when the key is not present. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L250-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.get!-Tuple{SortedDict, Any, Any}" href="#Base.get!-Tuple{SortedDict, Any, Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.get!(sd::SortedDict,k,default)
Base.get!(default_f::Union{Function,Type}, sd::SortedDict, k)</code></pre><p>Return the value associated with key <code>k</code> where <code>sd</code> is a SortedDict, or else return <code>default</code> if <code>k</code> is not in <code>sd</code>, and in the latter case, inserts <code>(k,default)</code> into <code>sd</code>.  The second form computes a default value by calling the function <code>default_f</code> (with no arguments) or the constructor of type <code>default_f</code> when the key is not present. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L275-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getkey-Tuple{SortedDict, Any, Any}" href="#Base.getkey-Tuple{SortedDict, Any, Any}"><code>Base.getkey</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.getkey(sd::SortedDict,k,defaultk)</code></pre><p>Return the key <code>k</code> where <code>sd</code> is a SortedDict, if <code>k</code> is in <code>sd</code> else it returns <code>defaultk</code>. If the container uses in its ordering an <code>eq</code> method different from isequal (e.g., case-insensitive ASCII strings illustrated below), then the return value is the actual key stored in the SortedDict that is equivalent to <code>k</code> according to the <code>eq</code> method, which might not be equal to <code>k</code>. Similarly, if the user performs an implicit conversion as part of the call (e.g., the container has keys that are floats, but the <code>k</code> argument to <code>getkey</code> is an Int), then the returned key is the actual stored key rather than <code>k</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L304-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isequal-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord&lt;:Base.Order.Ordering}" href="#Base.isequal-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord&lt;:Base.Order.Ordering}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.isequal(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K,Ord &lt;: Ordering}
Base.issetequal(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K,Ord &lt;: Ordering}</code></pre><p>Check if two sorted sets are equal in the sense that they contain the same items. Note that <code>isequal</code> in this sense does not imply correspondence between semitokens for items in <code>sc1</code> with those for <code>sc2</code>.  Time: O(<em>cn</em>) where n is the size of the smaller container.  If the two sorted sets have <code>K</code>, different <code>Ord</code>, or  different order objects, then a fallback routine <code>isequal(::AbstractSet, ::AbstractSet)</code> is invoked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L257-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, SortedDict{K, V, Ord}}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, SortedDict{K, V, Ord}}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.isequal(sd1::SortedDict{K,V,Ord}, sd2::SortedDict{K,V,Ord}) where {K, V, Ord &lt;: Ordering}</code></pre><p>Check if two SortedDicts are equal in the sense that they contain the same items; the keys are compared using the <code>eq</code> method, while the values are compared with the <code>isequal</code> function.   Note that <code>isequal</code> in this sense does not imply correspondence between semitokens for items in <code>sd1</code> with those for <code>sd2</code>.   Time: O(<em>cn</em>). Note that if <code>K</code>, <code>V</code>, <code>Ord</code>, or the order objects of sd1 and sd2 are different, then a fallback routine <code>Base.isequal(::AbstractDict, ::AbstractDict)</code> is invoked. Time: O(<em>cn</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L369-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedMultiDict{K, V, Ord}, SortedMultiDict{K, V, Ord}}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#Base.isequal-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedMultiDict{K, V, Ord}, SortedMultiDict{K, V, Ord}}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.isequal(smd1::SortedMultiDict{K,V,Ord}, smd2::SortedMultiDict{K,V,Ord}) where {K, V, Ord &lt;: Ordering}</code></pre><p>Check if two SortedMultiDicts are equal in the sense that they contain the same items in the same order (that is, the same insertion order). They must have the same order object, else they compare unequal. The keys are compared using the <code>eq</code> method, while the values are compared with the <code>isequal</code> function. Note that <code>isequal</code> in this sense does not imply any correspondence between semitokens for items in <code>smd1</code> with those for <code>smd2</code>.  Time: O(<em>cn</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.packcopy-Tuple{SortedSet}" href="#DataStructures.packcopy-Tuple{SortedSet}"><code>DataStructures.packcopy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(sc::SortedSet)
copy(sc::SortedDict)
copy(sc::SortedMultiDict)
packcopy(sc::SortedSet)
packcopy(sc::SortedDict)
packcopy(sc::SortedMultiDict)</code></pre><p>Return a copy of <code>sc</code>, where <code>sc</code> is a sorted container, in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em>)</p><p>Note that the semitokens valid for the original container are no longer valid for the copy because the indexing structure is rebuilt by these copies.  If an exact copy is needed in which semitokens remain valid, use <code>Base.deepcopy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L677-L695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataStructures.packdeepcopy-Tuple{SortedSet}" href="#DataStructures.packdeepcopy-Tuple{SortedSet}"><code>DataStructures.packdeepcopy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">packdeepcopy(sc::SortedSet)
packdeepcopy(sc::SortedDict)
packdeepcopy(sc::SorteMultiDict)</code></pre><p>Return a packed copy of <code>sc</code>, where <code>sc</code> is a sorted container in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L701-L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#Base.merge-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.merge(sd::SortedDict{K,V,Ord}, d1::AbstractDict{K,V}...) where {K,V,Ord &lt;: Ordering}</code></pre><p>Merge one or more dicts into a single SortedDict and return the new SortedDict.  Arguments <code>d1</code> etc. must have the same key-value type as <code>sd</code>. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored.  Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.  If all the arguments are SortedDicts with the same key, value, and order object, then the time is O(<em>cN</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L481-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge!-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord&lt;:Base.Order.Ordering}" href="#Base.merge!-Union{Tuple{Ord}, Tuple{V}, Tuple{K}, Tuple{SortedDict{K, V, Ord}, Vararg{AbstractDict{K, V}}}} where {K, V, Ord&lt;:Base.Order.Ordering}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.merge!(sd::SortedDict{K,V,Ord}, d1::AbstractDict{K,V}...) where {K,V,Ord&lt;:Ordering}</code></pre><p>Merge one or more dicts <code>d1</code>, etc. into <code>sd</code>. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored. Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_dict.jl#L463-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge-Tuple{SortedMultiDict, Vararg{Any}}" href="#Base.merge-Tuple{SortedMultiDict, Vararg{Any}}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.merge(smd::SortedMultiDict, iter...)</code></pre><p>Merge <code>smd</code> and one or more iterables and return the resulting new SortedMultiDict. The iterables must have the same key-value type as <code>smd</code>. Items with equal keys are stored with left-to-right ordering.   Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.  If all the arguments are SortedMultiDicts with the same key, value, and order object, then the time is O(<em>cN</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L365-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge!-Tuple{SortedMultiDict, Vararg{Any}}" href="#Base.merge!-Tuple{SortedMultiDict, Vararg{Any}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.merge!(smd::SortedMultiDict, iter...)</code></pre><p>Merge one or more iterables <code>iter</code>, etc. into <code>smd</code>. These must all must have the same key-value types. Items with equal keys are stored with left-to-right ordering.  Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_multi_dict.jl#L348-L356">source</a></section></article><h2 id="Set-operations"><a class="docs-heading-anchor" href="#Set-operations">Set operations</a><a id="Set-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Set-operations" title="Permalink"></a></h2><p>The SortedSet container supports the following set operations. Note that in the case of <code>intersect</code>, <code>symdiff</code> and <code>setdiff</code>, the two SortedSets should have the same key and ordering object. If they have different key or ordering types, no error message is produced; instead, the built-in default versions of these functions (that can be applied to <code>Any</code> iterables and that return arrays) are invoked.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.union!-Tuple{SortedSet, Vararg{Any}}" href="#Base.union!-Tuple{SortedSet, Vararg{Any}}"><code>Base.union!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.union!(ss::SortedSet, iterable...)</code></pre><p>Insert each item among the second and following arguments  (which must be iterable) into the SortedSet <code>ss</code>. The items must be convertible to the key-type of <code>ss</code>. Time: O(<em>cN</em> log <em>N</em>) where <em>N</em> is the total number of items in the iterable arguments.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L292-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.union-Tuple{SortedSet, Vararg{Any}}" href="#Base.union-Tuple{SortedSet, Vararg{Any}}"><code>Base.union</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.union(ss::SortedSet, iterable...)</code></pre><p>Compute and return the union of a sorted set and one or more iterables.  They must have the same keytype.  If they are all sorted sets with the same order object, then the required time is O(<em>cn</em>), where <em>n</em> is the total size.  If not, then the fallback routine requires time O(<em>cn</em> log <em>n</em>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L349-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect-Tuple{SortedSet, Vararg{Any}}" href="#Base.intersect-Tuple{SortedSet, Vararg{Any}}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.intersect(ss::SortedSet, others...)</code></pre><p>Intersect SortedSets with other SortedSets or other iterables and return the intersection as a new SortedSet. Time: O(<em>cn</em>), where <em>n</em> is the total number of items in all the arguments if all the arguments are SortedSets of the same type and same order object.  Otherwise, the time is O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L443-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.symdiff-Tuple{SortedSet, Any}" href="#Base.symdiff-Tuple{SortedSet, Any}"><code>Base.symdiff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.symdiff(ss1::SortedSet, iterable)</code></pre><p>Compute and return the symmetric difference of <code>ss1</code> and <code>iterable</code>, i.e., a sorted set containing entries that are in one of <code>ss1</code> or <code>iterable</code> but not both. Time: O(<em>cn</em>), where <em>n</em> is the total size of the two containers if both are sorted sets with the same key and order objects. Otherwise, the time is O(<em>cn</em> log <em>n</em>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L506-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setdiff-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord&lt;:Base.Order.Ordering}" href="#Base.setdiff-Union{Tuple{Ord}, Tuple{K}, Tuple{SortedSet{K, Ord}, SortedSet{K, Ord}}} where {K, Ord&lt;:Base.Order.Ordering}"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setdiff(ss1::SortedSet{K,Ord}, ss2::SortedSet{K,Ord}) where {K, Ord&lt;:Ordering}
Base.setdiff(ss1::SortedSet, others...)</code></pre><p>Return the set difference, i.e., a sorted set containing entries in <code>ss1</code> but not in <code>ss2</code> or successive arguments.   Time for the first form: O(<em>cn</em>) where <em>n</em> is the total size of both sets provided that they are both sorted sets of the same type and order object.   The second form computes the set difference between <code>ss1</code> and all the others, which are all iterables.  The second form requires O(<em>cn</em> log <em>n</em>) time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L579-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setdiff!-Tuple{SortedSet, Any}" href="#Base.setdiff!-Tuple{SortedSet, Any}"><code>Base.setdiff!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setdiff!(ss::SortedSet, iterable..)</code></pre><p>Delete items in <code>ss</code> that appear in any of the iterables. The arguments after the first  must be iterables each of whose entries must  convertible to the key type of m1.  Time: O(<em>cm</em> log <em>n</em>), where <em>n</em> is the size of <code>ss</code> and <em>m</em> is the  total number of items in iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L607-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.issubset-Tuple{Any, SortedSet}" href="#Base.issubset-Tuple{Any, SortedSet}"><code>Base.issubset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.issubset(iterable, ss::SortedSet)</code></pre><p>Check whether each item of the first argument is an element of  <code>ss</code>. The entries must be convertible to the key-type of <code>ss</code>. Time: O(<em>cm</em> log <em>n</em>), where <em>n</em> is the size of <code>ss</code> and <em>m</em> is the number of items in <code>iterable</code>.  If both are sorted sets of the same keytype and order object and if <em>m</em> &gt; <em>n</em> / log <em>n</em>, then an algorithm whose running time is O(<em>c</em>(<em>m</em>+<em>n</em>)) is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/84dc88d6b034dbbc10767d17730fa5b1c8949475/src/sorted_set.jl#L629-L638">source</a></section></article><h2 id="Ordering-of-keys"><a class="docs-heading-anchor" href="#Ordering-of-keys">Ordering of keys</a><a id="Ordering-of-keys-1"></a><a class="docs-heading-anchor-permalink" href="#Ordering-of-keys" title="Permalink"></a></h2><p>As mentioned earlier, the default ordering of keys uses <code>isless</code> and <code>isequal</code> functions. If the default ordering is used, it is a requirement of the container that <code>isequal(a,b)</code> is true if and only if <code>!isless(a,b)</code> and <code>!isless(b,a)</code> are both true. This relationship between <code>isequal</code> and <code>isless</code> holds for common built-in types, but it may not hold for all types, especially user-defined types. If it does not hold for a certain type, then a custom ordering argument must be defined as discussed in the next few paragraphs.</p><p>The name for the default ordering (i.e., using <code>isless</code> and <code>isequal</code>) is <code>Forward</code>. Note: this is the name of the ordering object; its type is <code>ForwardOrdering.</code> Another possible ordering object is <code>Reverse</code>, which reverses the usual sorted order. This name must be imported <code>import Base.Reverse</code> if it is used.</p><p>As an example of a custom ordering, suppose the keys are of type <code>String</code>, and the user wishes to order the keys ignoring case: <em>APPLE</em>, <em>berry</em> and <em>Cherry</em> would appear in that order, and <em>APPLE</em> and <em>aPPlE</em> would be indistinguishable in this ordering.</p><p>The simplest approach is to define an ordering object of the form <code>Lt(my_isless)</code>, where <code>Lt</code> is a built-in type (see <code>ordering.jl</code>) and <code>my_isless</code> is the user&#39;s comparison function. In the above example, the ordering object would be:</p><pre><code class="language-julia hljs">Lt((x,y) -&gt; isless(lowercase(x),lowercase(y)))</code></pre><p>The ordering object is indicated in the above list of constructors in the <code>o</code> position (see above for constructor syntax).</p><p>This approach may suffer from a performance hit because higher performance may be possible if an equality method is also available as well as a less-than method. A more complicated but higher-performance method to implement a custom ordering is as follows. First, the user creates a singleton type that is a subtype of <code>Ordering</code> as follows:</p><pre><code class="language-julia hljs">struct CaseInsensitive &lt;: Ordering
end</code></pre><p>Next, the user defines a method named <code>lt</code> for less-than in this ordering:</p><pre><code class="language-julia hljs">lt(::CaseInsensitive, a, b) = isless(lowercase(a), lowercase(b))</code></pre><p>The first argument to <code>lt</code> is an object of the <code>CaseInsensitive</code> type (there is only one such object since it is a singleton type). The container also needs an equal-to function; the default is:</p><pre><code class="language-julia hljs">eq(o::Ordering, a, b) = !lt(o, a, b) &amp;&amp; !lt(o, b, a)</code></pre><p>The user can also customize this function with a more efficient implementation. In the above example, an appropriate customization would be:</p><pre><code class="language-julia hljs">eq(::CaseInsensitive, a, b) = isequal(lowercase(a), lowercase(b))</code></pre><p>Note: the user-defined <code>eq</code> and <code>lt</code> functions must be compatible in the sense that <code>!lt(o, a, b) &amp;&amp; !lt(o, b, a)</code> if and only if  <code>eq(o, a, b)</code>.</p><p>Finally, the user specifies the unique element of <code>CaseInsensitive</code>, namely the object <code>CaseInsensitive()</code>, as the ordering object to the <code>SortedDict</code>, <code>SortedMultiDict</code> or <code>SortedSet</code> constructor.</p><p>For the above code to work, the module must make the following declarations, typically near the beginning:</p><pre><code class="language-julia hljs">import Base.Ordering
import Base.lt
import DataStructures.eq</code></pre><h2 id="Cautionary-note-on-mutable-keys"><a class="docs-heading-anchor" href="#Cautionary-note-on-mutable-keys">Cautionary note on mutable keys</a><a id="Cautionary-note-on-mutable-keys-1"></a><a class="docs-heading-anchor-permalink" href="#Cautionary-note-on-mutable-keys" title="Permalink"></a></h2><p>As with ordinary Dicts, keys for the sorted containers can be either mutable or immutable. In the case of mutable keys, it is important that the keys not be mutated once they are in the container else the indexing structure will be corrupted. (The same restriction applies to Dict.) For example, the following sequence of statements leaves <code>sd</code> in a corrupted state:</p><pre><code class="language-julia hljs">sd = SortedDict{Vector{Int},Int}()
k = [1,2,3]
sd[k] = 19
sd[[6,4]] = 12
k[1] = 7</code></pre><h2 id="Performance-of-Sorted-Containers"><a class="docs-heading-anchor" href="#Performance-of-Sorted-Containers">Performance of Sorted Containers</a><a id="Performance-of-Sorted-Containers-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-of-Sorted-Containers" title="Permalink"></a></h2><p>The sorted containers are currently not optimized for cache performance.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intset/">« DataStructures.IntSet</a><a class="docs-footer-nextpage" href="../dibit_vector/">DiBitVector »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Tuesday 18 March 2025 16:29">Tuesday 18 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
